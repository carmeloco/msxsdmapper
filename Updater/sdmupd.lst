0001   0000             ; Projeto MSX SD Mapper
0002   0000             
0003   0000             ; Copyright (c) 2014
0004   0000             ; Fabio Belavenuto
0005   0000             ;
0006   0000             ; Baseado no código FL2 versão 2.2 de 29-12-2002  (c) Ramones 2002
0007   0000             ;
0008   0000             ;
0009   0000             ; This documentation describes Open Hardware and is licensed under the CERN OHL v. 1.1.
0010   0000             ; You may redistribute and modify this documentation under the terms of the
0011   0000             ; CERN OHL v.1.1. (http://ohwr.org/cernohl). This documentation is distributed
0012   0000             ; WITHOUT ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING OF MERCHANTABILITY,
0013   0000             ; SATISFACTORY QUALITY AND FITNESS FOR A PARTICULAR PURPOSE.
0014   0000             ; Please see the CERN OHL v.1.1 for applicable conditions
0015   0000             
0016   0000             
0017   0000             	output	"sdmupd.com"
0018   0000             
0019   0000             	include	"bios.inc"
0001+  0000             ;
0002+  0000             ; BIOS definitions
0003+  0000             ;
0004+  0000             
0005+  0000             PSLTRG			= $A8			; I/O port address of primary slot register
0006+  0000             
0007+  0000             WBOOT			= $00
0008+  0000             RDSLT			= $0C
0009+  0000             WRSLT			= $14
0010+  0000             CALSTL			= $1C
0011+  0000             ENASLT			= $24
0012+  0000             IDBYT0			= $2B
0013+  0000             BASVER			= $2D
0014+  0000             CALLF			= $30
0015+  0000             KEYINT			= $38
0016+  0000             WRTVDP			= $47
0017+  0000             LDIRMV			= $59
0018+  0000             LDIRVM			= $5C
0019+  0000             CHGMOD			= $5F
0020+  0000             INITXT			= $6C
0021+  0000             CHSNS			= $9C
0022+  0000             CHGET			= $9F
0023+  0000             CHPUT			= $A2
0024+  0000             LPTOUT			= $A5
0025+  0000             BREAKX			= $B7
0026+  0000             CKCNTC			= $BD
0027+  0000             ERAFNK			= $CC
0028+  0000             TOTEXT			= $D2
0029+  0000             SNSMAT			= $141
0030+  0000             PHYDIO			= $144
0031+  0000             KILBUF			= $156
0032+  0000             CALBAS			= $159
0033+  0000             EXTROM			= $15F
0034+  0000             
0035+  0000             RDPRIM			= $F380
0036+  0000             WRPRIM			= $F385
0037+  0000             CLPRIM			= $F38C
0038+  0000             CLPRM1			= $F398
0039+  0000             LINL40			= $F3AE
0040+  0000             LINLEN			= $F3B0
0041+  0000             CNSDFG			= $F3DE
0042+  0000             LPTPOS			= $F415
0043+  0000             PRTFLG			= $F416
0044+  0000             CURLIN			= $F41C
0045+  0000             KBUF			= $F41F
0046+  0000             BUF				= $F55E
0047+  0000             TTYPOS			= $F661
0048+  0000             VALTYP			= $F663
0049+  0000             MEMSIZ			= $F672
0050+  0000             STKTOP			= $F674
0051+  0000             TXTTAB			= $F676
0052+  0000             TEMPPT			= $F678
0053+  0000             TEMPST			= $F67A
0054+  0000             DSCTMP			= $F698
0055+  0000             FRETOP			= $F69B
0056+  0000             AUTLIN			= $F6AB
0057+  0000             SAVSTK			= $F6B1
0058+  0000             VARTAB			= $F6C2
0059+  0000             STREND			= $F6C6
0060+  0000             DAC				= $F7F6
0061+  0000             ARG				= $F847
0062+  0000             MAXFIL			= $F85F
0063+  0000             FILTAB			= $F860
0064+  0000             NULBUF			= $F862
0065+  0000             PTRFIL			= $F864
0066+  0000             FILNAM			= $F866
0067+  0000             NLONLY			= $F87C
0068+  0000             SAVEND			= $F87D
0069+  0000             EXBRSA			= $FAF0
0070+  0000             HOKVLD			= $FB20
0071+  0000             YFB21			= $FB21					; diskdriver table
0072+  0000             YFB29			= $FB29					; diskdriver interrupt table
0073+  0000             BOTTOM			= $FC48
0074+  0000             HIMEM			= $FC4A
0075+  0000             CSRSW			= $FCA9
0076+  0000             FLBMEM			= $FCAE
0077+  0000             RUNBNF			= $FCBE
0078+  0000             SAVENT			= $FCBF
0079+  0000             EXPTBL			= $FCC1					; slots expanded or not
0080+  0000             SLTTBL			= $FCC5
0081+  0000             SLTATR			= $FCC9
0082+  0000             SLTWRK			= $FD09
0083+  0000             PROCNM			= $FD89
0084+  0000             DEVICE			= $FD99
0085+  0000             H.TIMI			= $FD9F
0086+  0000             H.KEYI			= $FD9A					; interrupt hook
0087+  0000             H.DSKO			= $FDEF
0088+  0000             H.NAME			= $FDF9
0089+  0000             H.KILL			= $FDFE
0090+  0000             H.COPY			= $FE08
0091+  0000             H.DSKF			= $FE12
0092+  0000             H.DSKI			= $FE17
0093+  0000             H.LSET			= $FE21
0094+  0000             H.RSET			= $FE26
0095+  0000             H.FIEL			= $FE2B
0096+  0000             H.MKI			= $FE30
0097+  0000             H.MKS			= $FE35
0098+  0000             H.MKD			= $FE3A
0099+  0000             H.CVI			= $FE3F
0100+  0000             H.CVS			= $FE44
0101+  0000             H.CVD			= $FE49
0102+  0000             H.GETP			= $FE4E
0103+  0000             H.NOFO			= $FE58
0104+  0000             H.NULO			= $FE5D
0105+  0000             H.NTFL			= $FE62
0106+  0000             H.BINS			= $FE71
0107+  0000             H.BINL			= $FE76
0108+  0000             H.FILE			= $FE7B
0109+  0000             H.DGET			= $FE80
0110+  0000             H.FILO			= $FE85
0111+  0000             H.INDS			= $FE8A
0112+  0000             H.LOC			= $FE99
0113+  0000             H.LOF			= $FE9E
0114+  0000             H.EOF			= $FEA3
0115+  0000             H.BAKU			= $FEAD
0116+  0000             H.PARD			= $FEB2
0117+  0000             H.NODE			= $FEB7
0118+  0000             H.POSD			= $FEBC
0119+  0000             H.RUNC			= $FECB
0120+  0000             H.CLEA			= $FED0
0121+  0000             H.LOPD			= $FED5
0122+  0000             H.STKE			= $FEDA
0123+  0000             H.ERRP			= $FEFD
0124+  0000             H.PHYD			= $FFA7
0125+  0000             H.FORM			= $FFAC
0126+  0000             EXTBIO			= $FFCA
0127+  0000             DISINT			= $FFCF
0128+  0000             ENAINT			= $FFD4
0129+  0000             EXTVDP			= $FFE7
0130+  0000             
0020   0000             	include	"bdos.inc"
0001+  0000             ;
0002+  0000             ; MSX-DOS definitions
0003+  0000             ;
0004+  0000             
0005+  0000             BDOS			= 5
0006+  0000             
0007+  0000             	MACRO BdosCall function
0008+  0000~            		ld		c, function
0009+  0000~            		call	BDOS
0010+  0000             	ENDM
0011+  0000             
0012+  0000             _TERM0			= $00					; Program terminate
0013+  0000             _CONIN			= $01					; Console input
0014+  0000             _CONOUT			= $02					; Console output
0015+  0000             _AUXIN			= $03					; Auxiliary input
0016+  0000             _AUXOUT			= $04					; Auxiliary output
0017+  0000             _LSTOUT			= $05					; Printer output
0018+  0000             _DIRIO			= $06					; Direct console I/O
0019+  0000             _DIRIN			= $07					; Direct console input
0020+  0000             _INNOE			= $08					; Console input without echo
0021+  0000             _STROUT			= $09					; String output
0022+  0000             _BUFIN			= $0A					; Buffered line input
0023+  0000             _CONST			= $0B					; Console status
0024+  0000             _CPMVER			= $0C					; Return version number
0025+  0000             _DSKRST			= $0D					; Disk reset
0026+  0000             _SELDSK			= $0E					; Select disk
0027+  0000             _FOPEN			= $0F					; Open file
0028+  0000             _FCLOSE			= $10					; Close file
0029+  0000             _SFIRST			= $11					; Search for first
0030+  0000             _SNEXT			= $12					; Search for next
0031+  0000             _FDEL			= $13					; Delete file
0032+  0000             _RDSEQ			= $14					; Sequencial read
0033+  0000             _WRSEQ			= $15					; Sequencial write
0034+  0000             _FMAKE			= $16					; Create file
0035+  0000             _FREN			= $17					; Rename file
0036+  0000             _LOGIN          = $18					; Get login vector
0037+  0000             _CURDRV			= $19					; Get current drive
0038+  0000             _SETDTA			= $1A					; Set disk transfer address
0039+  0000             _ALLOC			= $1B					; Get allocation information
0040+  0000             _RDRND			= $21					; Random read
0041+  0000             _WRRND			= $22					; Random write
0042+  0000             _FSIZE			= $23					; Get file size
0043+  0000             _SETRND			= $24					; Set random record
0044+  0000             _WRBLK			= $26					; Random block write
0045+  0000             _RDBLK			= $27					; Random block read
0046+  0000             _WRZER			= $28					; Random write with zero fill
0047+  0000             _GDATE			= $2A					; Get date
0048+  0000             _SDATE			= $2B					; Set date
0049+  0000             _GTIME			= $2C					; Get time
0050+  0000             _STIME			= $2D					; Set time
0051+  0000             _VERIFY			= $2E					; Set/reset verify flag
0052+  0000             _RDABS			= $2F					; Absolute sector read
0053+  0000             _WRABS			= $30					; Absolute sector write
0054+  0000             _DPARM			= $31					; Get disk parameters
0055+  0000             _FFIRST			= $40					; Find first entry
0056+  0000             _FNEXT			= $41					; Find next entry
0057+  0000             _FNEW			= $42					; Find = entry
0058+  0000             _OPEN			= $43					; Open file handle
0059+  0000             _CREATE			= $44					; Create file handle
0060+  0000             _CLOSE			= $45					; Close file handle
0061+  0000             _ENSURE			= $46					; Ensure file handle
0062+  0000             _DUP			= $47					; Duplicate file handle
0063+  0000             _READ			= $48					; Read from file handle
0064+  0000             _WRITE			= $49					; Write to file handle
0065+  0000             _SEEK			= $4A					; Move file handle pointer
0066+  0000             _IOCTL			= $4B					; I/O control for devices
0067+  0000             _HTEST			= $4C					; Test file handle
0068+  0000             _DELETE			= $4D					; Delete file or subdirectory
0069+  0000             _RENAME			= $4E					; Rename file or subdirectory
0070+  0000             _MOVE			= $4F					; Move file or subdirectory
0071+  0000             _ATTR			= $50					; Get/set file attributes
0072+  0000             _FTIME			= $51					; Get/set file date and time
0073+  0000             _HDELETE		= $52					; Delete file handle
0074+  0000             _HRENAME		= $53					; Rename file handle
0075+  0000             _HMOVE			= $54					; Move file handle
0076+  0000             _HATTR			= $55					; Get/set file handle attributes
0077+  0000             _HFTIME			= $56					; Get/set file handle date and time
0078+  0000             _GETDTA			= $57					; Get disk transfer address
0079+  0000             _GETVFY			= $58					; Get verify flag setting
0080+  0000             _GETCD			= $59					; Get current directory
0081+  0000             _CHDIR			= $5A					; Change current directory
0082+  0000             _PARSE			= $5B					; Parse pathname
0083+  0000             _PFILE			= $5C					; Parse filename
0084+  0000             _CHKCHR			= $5D					; Check character
0085+  0000             _WPATH			= $5E					; Get whole path string
0086+  0000             _FLUSH			= $5F					; Flush disk buffers
0087+  0000             _FORK			= $60					; Fork a child process
0088+  0000             _JOIN			= $61					; Rejoin parent process
0089+  0000             _TERM			= $62					; Terminate with error code
0090+  0000             _DEFAB			= $63					; Define abort exit routine
0091+  0000             _DEFER			= $64					; Define disk error handler routine
0092+  0000             _ERROR			= $65					; GFet previous error code
0093+  0000             _EXPLAIN		= $66					; Explain error code
0094+  0000             _FORMAT			= $67					; Format a disk
0095+  0000             _RAMD			= $68					; Create or destroy RAM disk
0096+  0000             _BUFFER			= $69					; Allocate sector buffers
0097+  0000             _ASSGIN			= $6A					; Logical drive assignment
0098+  0000             _GENV			= $6B					; Get environment item
0099+  0000             _SENV			= $6C					; Set environment item
0100+  0000             _FENV			= $6D					; Find environment item
0101+  0000             _DSKCHK			= $6E					; Get/set disk check status
0102+  0000             _DOSVER			= $6F					; Get MSX DOS version number
0103+  0000             _REDIR			= $70					; Get/set redirection status
0104+  0000             
0105+  0000             ; Errors
0106+  0000             ERROR: 
0107+  0000             .NCOMP			= $FF					; Incompatible disk
0108+  0000             .WRERR			= $FE					; Write error
0109+  0000             .DISK			= $FD					; Disk error
0110+  0000             .NRDY			= $FC					; Not ready
0111+  0000             .VERFY			= $FB					; Verify error
0112+  0000             .DATA			= $FA					; Data error
0113+  0000             .RNF			= $F9					; Sector not found
0114+  0000             .WPROT			= $F8					; Write protected disk
0115+  0000             .UFORM			= $F7					; Unformatted disk
0116+  0000             .NDOS			= $F6					; Not a DOS disk
0117+  0000             .WDISK			= $F5					; Wrong disk
0118+  0000             .WFILE			= $F4					; Wrong disk for file
0119+  0000             .SEEK			= $F3					; Seek error
0120+  0000             .IFAT			= $F2					; Bad file allocation table
0121+  0000             .NOUPB			= $F1					; --
0122+  0000             .IFORM			= $F0					; Cannot format this drive
0123+  0000             .INTER			= $DF					; Internal error
0124+  0000             .NORAM			= $DE					; Not enough memory
0125+  0000             .IBDOS			= $DC					; Invalid MSX-DOS call
0126+  0000             .IDRV			= $DB					; Invalid drive
0127+  0000             .IFNM			= $DA					; Invalid filename
0128+  0000             .IPATH			= $D9					; Invalid pathname
0129+  0000             .PLONG			= $D8					; Pathname too long
0130+  0000             .NOFIL			= $D7					; File not found
0131+  0000             .NODIR			= $D6					; Directory not found
0132+  0000             .DRFUL			= $D5					; Root directory full
0133+  0000             .DKFUL			= $D4					; Disk full
0134+  0000             .DUPF			= $D3					; Duplicate filename
0135+  0000             .DIRE			= $D2					; Invalid directory move
0136+  0000             .FILRO			= $D1					; Read only file
0137+  0000             .DIRNE			= $D0					; Directory not empty
0138+  0000             .IATTR			= $CF					; Invalid attributes
0139+  0000             .DOT			= $CE					; Invalid . or .. operation
0140+  0000             .SYSX			= $CD					; System file exists
0141+  0000             .DIRX			= $CC					; Directory exists
0142+  0000             .FILEX			= $CB					; File exists
0143+  0000             .FOPEN			= $CA					; File already in use
0144+  0000             .OV64K			= $C9					; Cannot transfer above 64K
0145+  0000             .FILE			= $C8					; File allocation error
0146+  0000             .EOF			= $C7					; End of file
0147+  0000             .ACCV			= $C6					; File access violation
0148+  0000             .IPROC			= $C5					; Invalid process id
0149+  0000             .NHAND			= $C4					; No spare file handles
0150+  0000             .IHAND			= $C3					; Invalid file handle
0151+  0000             .NOPEN			= $C2					; File handle not open
0152+  0000             .IDEV			= $C1					; Invalid device operation
0153+  0000             .IENV			= $C0					; Invalid environment string
0154+  0000             .ELONG			= $BF					; Environment string too long
0155+  0000             .IDATE			= $BE					; Invalid date
0156+  0000             .ITIME			= $BD					; Invalid time
0157+  0000             .RAMDX			= $BC					; RAM disk (drive H ) already exists
0158+  0000             .NRAMD			= $BB					; RAM disk does not exist
0159+  0000             .HDEAD			= $BA					; File handle has been deleted
0160+  0000             .EOL			= $B9					; Internal error. Should never occur
0161+  0000             .ISBFN			= $B8					; Invalid sub-function number
0162+  0000             .STOP			= $9F					; Ctrl-STOP pressed
0163+  0000             .CTRLC			= $9E					; Ctrl-C pressed
0164+  0000             .ABORT			= $9D					; Disk operation aborted
0165+  0000             .OUTERR			= $9C					; Error on standard output
0166+  0000             .INERR			= $9B					; Error on standard input
0167+  0000             .BADCOM			= $8F					; Wrong version of COMMAND
0168+  0000             .BADCM			= $8E					; Unrecognized command
0169+  0000             .BUFUL			= $8D					; Command too long
0170+  0000             .OKCMD			= $8C					; --
0171+  0000             .IPARM			= $8B					; Invalid parameter
0172+  0000             .INP			= $8A					; Too many parameters
0173+  0000             .NOPAR			= $89					; Missing parameter
0174+  0000             .IOPT			= $88					; Invalid option
0175+  0000             .BADNO			= $87					; Invalid number
0176+  0000             .NOHELP			= $86					; File for HELP not found
0177+  0000             .BADVER			= $85					; Wrong version of MSX-DOS
0178+  0000             .NOCAT			= $84					; Cannot concatenate destination file
0179+  0000             .BADEST			= $83					; Cannot create destination file
0180+  0000             .COPY			= $82					; File cannot be copied onto itself
0181+  0000             .OVDEST			= $81					; Cannot overwrite previous destination file
0182+  0000             
0183+  0000             ; Allocate segment parameters
0184+  0000             USER_SEGMENT		= 0					; Register A
0185+  0000             SYSTEM_SEGMENT		= 1					; "        "
0186+  0000             PRIMARY_MAPPER		= 0					; Register B 
0187+  0000             
0188+  0000             ; Open file flags (_OPEN)
0189+  0000             OPEN_NO_WRITE		= 1
0190+  0000             OPEN_NO_READ		= 2
0191+  0000             OPEN_INHERITABLE	= 4
0192+  0000             
0193+  0000             ; Seek file flags
0194+  0000             SEEK_SET			= 0
0195+  0000             SEEK_CUR			= 1
0196+  0000             SEEK_END			= 2
0197+  0000             
0198+  0000             ; File attributes (bit mask)
0199+  0000             FILE_READ_ONLY		= 1					; 
0200+  0000             FILE_HIDDEN			= 2					;
0201+  0000             FILE_SYSTEM			= 4					; 
0202+  0000             FILE_VOLUME_NAME	= 8					; 
0203+  0000             FILE_DIRECTORY		= 16				; 
0204+  0000             FILE_ARCHIVE		= 32				; 
0205+  0000             FILE_RESERVED		= 64				; 
0206+  0000             FILE_DEVICE			= 128				;
0207+  0000             
0208+  0000             ; Disk error handler routine parameters in register C
0209+  0000             ERROR_WRITING		= 1					; Set if writing
0210+  0000             ERROR_NO_IGNORE		= 2					; Set if ignore not recommended
0211+  0000             ERROR_AUTO_ABORT	= 4					; Set if auto-abort suggested
0212+  0000             ERROR_VALID_SECTOR	= 8					; Set if sector number is valid 
0213+  0000             
0214+  0000             
0215+  0000             ; Disk error handler routine return codes
0216+  0000             CALL_SYSTEM_ERROR	= 0					; Call system error routine
0217+  0000             ERROR_ABORT			= 1					; Abort
0218+  0000             ERROR_RETRY			= 2					; Retry
0219+  0000             ERROR_IGNORE		= 3					; Ignore
0220+  0000             
0221+  0000             
0222+  0000             ;  Params _RAMD
0223+  0000             DESTROY_RAMDISK		= 0
0224+  0000             GET_RAMDISK_SIZE	= $FF
0225+  0000             CREATE_RAMDISK		= 1					; CREATE_RAMDISK+n = 1+n
0226+  0000             
0227+  0000             ; Misc
0228+  0000             CR					= 13				; Carridge Return
0229+  0000             LF					= 10				; Line Feed
0230+  0000             LE					= '$'				; Line end
0231+  0000             UPPER_CASE_MASK		= $DF
0232+  0000             
0233+  0000             CMD_LENGTH			= $80
0234+  0000             CMD_LINE			= $82
0235+  0000             
0236+  0000             COM_START_ADDR		= $100
0237+  0000             
0238+  0000             RAMAD0				= $F341				; slotid DOS ram page 0
0239+  0000             RAMAD1				= $F342				; slotid DOS ram page 1
0240+  0000             RAMAD2				= $F343				; slotid DOS ram page 2
0241+  0000             RAMAD3				= $F344				; slotid DOS ram page 3
0242+  0000             SECBUF				= $F34D				; pointer to sectorbuffer, can be used by the diskdriver
0243+  0000             
0021   0000             
0022   0000             
0023   0000             	org		COM_START_ADDR
0024   0100             
0025   0100             
0026   0100             ; *** CONSTANTS ***
0027   0100             ALG_BYTE	= 1
0028   0100             ALG_PAGE	= 2
0029   0100             
0030   0100             begin: 
0031   0100             
0032   0100             ; **** MAIN PROGRAM ****
0033   0100             
0034   0100             init: 
0035   0100             	; Actual parameters saved
0036   0100 ED 73 F0 09 	ld		(savesp), sp				; Stack Pointer saved
0037   0104 3A A9 FC    	ld		a, (CSRSW)					; Cursor Saved
0038   0107 32 F3 09    	ld		(savecursor), a
0039   010A CD FB 04    	call	cursorOff         			; Turn cursor off (no matter about its state)
0040   010D             
0041   010D 11 8F 06    	ld		de, strTitulo
0042   0110 CD 48 05    	call	print						; Print logo
0043   0113             
0044   0113 CD E3 01    	call	checkDOS					; Dos version checked
0045   0116 CD ED 01    	call	checkSystem					; MSX Type checked
0046   0119 CD 1A 02    	call	checkParams					; Check and Save parameters
0047   011C             
0048   011C 3A F6 09    	ld		a, (options)
0049   011F CB 4F       	bit		1, a						; only list chips?
0050   0121 C2 03 06    	jp nz,	showList					; yes, jump
0051   0124             
0052   0124 CD 3B 01    	call	checkFlash     				; Search FLASH ROM
0053   0127             
0054   0127 3A F6 09    	ld		a, (options)
0055   012A CB 47       	bit		0, a						; only erasing flash?
0056   012C C2 9E 04    	jp nz,	eraseFlash					; yes, jump to erase it
0057   012F             
0058   012F CD BB 02    	call	checkFile					; Checks if file-argument exists and your size
0059   0132 CD 9E 04    	call	eraseFlash					; Erase flash.
0060   0135 CD 29 03    	call	loadFile 					; Load file in flash
0061   0138             
0062   0138 C3 19 05    	jp		exitok						; No. Exit Program
0063   013B             
0064   013B             
0065   013B             ; *** CHECKING ROUTINES ***
0066   013B             
0067   013B             ; -------------------
0068   013B             ; checkFlash
0069   013B             ; Searches FLASH ROM
0070   013B             ; ------------------
0071   013B             checkFlash: 
0072   013B 11 9B 07    	ld		de, strProcuraFlash
0073   013E CD 48 05    	call	print						; Prints searching message
0074   0141 3E FF       	ld		a, $FF
0075   0143 32 F9 09    	ld		(thisslt), a				; Inits SIGSLOT Routine
0076   0146             .loop: 
0077   0146 F3          	di
0078   0147 CD D6 03    	call	sigslot						; Calls the next slot (first one if first time)
0079   014A FE FF       	cp		$FF							; Is it the last slot?
0080   014C 28 53       	jr z,	.naoachado					; Yes. FLASH was not found
0081   014E             
0082   014E F5          	push	af
0083   014F 26 40       	ld		h, $40						; It is not the last slot. Placed it in page 1
0084   0151 CD 24 00    	call	ENASLT
0085   0154 F1          	pop		af
0086   0155 26 80       	ld		h, $80						; Placed it in page 2 too
0087   0157 CD 24 00    	call	ENASLT
0088   015A             
0089   015A CD B7 01    	call	checkDeviceID				; Searching flash by executing its ID_CHECK command
0090   015D 38 E7       	jr c,	.loop						; Not found in this slot, continue with next one
0091   015F             
0092   015F 3A F9 09    	ld		a, (thisslt)				; FLASH WAS FOUND
0093   0162 32 FA 09    	ld		(flashslt), a				; Slot saved
0094   0165 F5          	push	af 							; For printing the message of slot / subslot
0095   0166 E6 03       	and		3
0096   0168 C6 30       	add		a, '0'						; ASCII conversion of the Slot
0097   016A 32 EB 07    	ld		(strAchado.slot), a
0098   016D F1          	pop		af
0099   016E 0F          	rrca
0100   016F 0F          	rrca
0101   0170 E6 03       	and		3
0102   0172 C6 30       	add		a, '0'
0103   0174 32 F5 07    	ld		(strAchado.subslot), a		; ASCII conversion of the Subslot.
0104   0177             
0105   0177 3A 42 F3    	ld		a, (RAMAD1)
0106   017A 26 40       	ld		h, $40
0107   017C CD 24 00    	call	ENASLT						; Restoring page 1 (Memory again)
0108   017F 3A 43 F3    	ld		a, (RAMAD2)
0109   0182 26 80       	ld		h, $80
0110   0184 CD 24 00    	call	ENASLT						; Restoring page 2 (Memory again)
0111   0187             
0112   0187 11 DD 07    	ld		de, strAchado
0113   018A CD 48 05    	call	print						; Printing message with info about slot / subslot
0114   018D ED 5B FE 09 	ld		de, (flashManPoint)			; recuperamos string do fabricante
0115   0191 CD 48 05    	call	print
0116   0194 ED 5B 00 0A 	ld		de, (flashProdPoint)		; recuperamos string do produto
0117   0198 CD 48 05    	call	print						; e imprimimos
0118   019B 11 C5 06    	ld		de, strCrLf
0119   019E C3 48 05    	jp		print
0120   01A1             
0121   01A1             .naoachado: 								; FLASH NOT FOUND
0122   01A1 3A 42 F3    	ld		a, (RAMAD1)
0123   01A4 26 40       	ld		h, $40
0124   01A6 CD 24 00    	call	ENASLT						; Memory placed
0125   01A9 3A 43 F3    	ld		a, (RAMAD2)
0126   01AC 26 80       	ld		h, $80
0127   01AE CD 24 00    	call	ENASLT						; Memory placed
0128   01B1 11 BF 07    	ld		de, strNaoAchado
0129   01B4 C3 14 05    	jp		printErro					; Error message, exiting program
0130   01B7             
0131   01B7             ; ------------------------
0132   01B7             ; checkDeviceID
0133   01B7             ; Check Flash Manufacturer and Device ID
0134   01B7             ; Z = 1 if Flash found
0135   01B7             ;
0136   01B7             ; -------------------------
0137   01B7             checkDeviceID: 
0138   01B7 F3          	di
0139   01B8 3E F0       	ld		a, $F0						; Reset
0140   01BA CD 18 04    	call	flashSendCommand
0141   01BD 3E 90       	ld		a, $90						; Software ID Entry
0142   01BF CD 18 04    	call	flashSendCommand
0143   01C2 3A 00 80    	ld		a, ($8000)					; Read Manufacturer ID
0144   01C5 32 FB 09    	ld		(flashIdMan), a
0145   01C8 3A 01 80    	ld		a, ($8001)					; Read Product ID
0146   01CB 32 FC 09    	ld		(flashIdProd), a
0147   01CE CD 4D 06    	call	flashIdent					; Try to identify flash
0148   01D1 3A FD 09    	ld		a, (flashAlg)
0149   01D4 FE 00       	cp		0
0150   01D6 37          	scf									; Carry = 1 - error
0151   01D7 28 01       	jr z,	.sair
0152   01D9             .ok: 
0153   01D9 AF          	xor		a							; Carry = 0 - OK
0154   01DA             .sair: 
0155   01DA F5          	push	af
0156   01DB 3E F0       	ld		a, $F0						; Reset
0157   01DD CD 18 04    	call	flashSendCommand
0158   01E0 F1          	pop		af
0159   01E1 FB          	ei
0160   01E2 C9          	ret
0161   01E3             
0162   01E3             ; ----------------------
0163   01E3             ; CHECK DOS
0164   01E3             ; check operating system
0165   01E3             ; ----------------------
0166   01E3             checkDOS: 
0167   01E3 0E 6F       	ld		c, _DOSVER
0168   01E5 CD 0C 05    	call	callBdos					; Send DOSVER command to dos
0169   01E8 78          	ld		a, b
0170   01E9 32 F4 09    	ld		(dos), a					; Save dos version
0171   01EC C9          	ret
0172   01ED             
0173   01ED             ; ----------------
0174   01ED             ; checkSystem
0175   01ED             ; check MSX
0176   01ED             ; ----------------
0177   01ED             checkSystem: 
0178   01ED 3A C1 FC    	ld		a, (EXPTBL)
0179   01F0 21 2D 00    	ld		hl, BASVER
0180   01F3 CD 0C 00    	call	RDSLT						; Check byte $2D (MSX version)
0181   01F6 32 F5 09    	ld		(system), a
0182   01F9 FE 03       	cp		3							; Turbo R?
0183   01FB D8          	ret	c								; no, return
0184   01FC FD 2A C0 FC 	ld		iy, (EXPTBL - 1)			; is MSX Turbo R
0185   0200 DD 21 83 01 	ld		ix, $183
0186   0204 CD 1C 00    	call	CALSTL
0187   0207 F6 80       	or		$80
0188   0209 32 F2 09    	ld		(savecpu), a				; save actual CPU mode
0189   020C 3E 80       	ld		a, $80						; and set Z80 for compatibility
0190   020E             
0191   020E             systemSetCPU: 
0192   020E FD 2A C0 FC 	ld		iy, (EXPTBL - 1)
0193   0212 DD 21 80 01 	ld		ix, $180
0194   0216 CD 1C 00    	call	CALSTL
0195   0219 C9          	ret
0196   021A             
0197   021A             ; --------------------
0198   021A             ; checkParams
0199   021A             ; Check line params
0200   021A             ; --------------------
0201   021A             checkParams: 
0202   021A 21 80 00    	ld		hl, CMD_LENGTH
0203   021D 7E          	ld		a, (hl)
0204   021E B7          	or		a							; Parameters?
0205   021F 11 C8 06    	ld		de, strHelp
0206   0222 CA 14 05    	jp z,	printErro					; no parameters. Show Help and exit
0207   0225             
0208   0225 CD 7F 02    	call	checkOptions				; Check parameter options
0209   0228 CD 4D 02    	call	checkFileName				; Check file name
0210   022B             
0211   022B 3A F4 09    	ld		a, (dos)
0212   022E FE 02       	cp		2
0213   0230 D2 93 03    	jp nc,	fillName					; If DOS2 then fill only the name
0214   0233 21 09 0A    	ld		hl, fileNameDOS2			; DOS1. Extract filename
0215   0236 11 49 0A    	ld		de, fileNameDOS1
0216   0239             .loop0: 
0217   0239 7E          	ld		a,(hl)
0218   023A FE 2E       	cp		'.'
0219   023C 28 08       	jr z,	.loop2
0220   023E 12          	ld		(de), a
0221   023F 13          	inc		de
0222   0240             .loop1: 
0223   0240 23          	inc		hl
0224   0241 10 F6       	djnz	.loop0
0225   0243 C3 93 03    	jp		fillName
0226   0246             .loop2: 
0227   0246 11 51 0A    	ld		de, filenDOS1Ext
0228   0249 06 04       	ld		b, 4
0229   024B 18 F3       	jr		.loop1
0230   024D             
0231   024D             ; -------------------
0232   024D             ; checkFileName
0233   024D             ; Extract the name of
0234   024D             ; the parameters in
0235   024D             ; DOS2 format
0236   024D             ; ------------------
0237   024D             checkFileName: 
0238   024D 3A 80 00    	ld		a, (CMD_LENGTH)
0239   0250 FE 01       	cp		1
0240   0252 47          	ld		b, a
0241   0253 28 01       	jr z,	.p1
0242   0255 05          	dec		b
0243   0256             .p1: 
0244   0256 21 82 00    	ld		hl, CMD_LINE
0245   0259 11 09 0A    	ld		de, fileNameDOS2
0246   025C 0E 00       	ld		c, 0
0247   025E             .loop0: 
0248   025E 7E          	ld		a, (hl)
0249   025F B7          	or		a
0250   0260 28 11       	jr z,	.p2
0251   0262 FE 2F       	cp		'/'
0252   0264 CA 74 02    	jp z,	.p3
0253   0267 FE 20       	cp		' '
0254   0269 CA 73 02    	jp z,	.p2
0255   026C FE 0D       	cp		13
0256   026E 28 03       	jr z,	.p2
0257   0270 12          	ld		(de),a
0258   0271 13          	inc		de
0259   0272 0C          	inc		c
0260   0273             .p2: 
0261   0273 2B          	dec		hl
0262   0274             .p3: 
0263   0274 23          	inc		hl
0264   0275 23          	inc		hl
0265   0276 10 E6       	djnz	.loop0
0266   0278 41          	ld		b, c
0267   0279 79          	ld		a, c
0268   027A B7          	or		a
0269   027B C0          	ret	nz
0270   027C 06 01       	ld		b, 1
0271   027E C9          	ret
0272   027F             
0273   027F             ; --------------------------------------
0274   027F             ; checkOptions
0275   027F             ; OPTIONS :
0276   027F             ;			0 - erase flash only	/e
0277   027F             ;			1 - show list of chips	/l
0278   027F             ;
0279   027F             ; ---------------------------------------
0280   027F             checkOptions: 
0281   027F C5          	push	bc
0282   0280 AF          	xor		a
0283   0281 32 F6 09    	ld		(options), a
0284   0284 3A 80 00    	ld		a, (CMD_LENGTH)
0285   0287 47          	ld		b, a
0286   0288 21 82 00    	ld		hl, CMD_LINE
0287   028B             .loop0: 
0288   028B 7E          	ld		a, (hl)
0289   028C FE 2F       	cp		'/'
0290   028E CC 95 02    	call	z, .ch1
0291   0291             .p1: 
0292   0291 23          	inc		hl
0293   0292 10 F7       	djnz	.loop0
0294   0294 C1          	pop		bc
0295   0295             
0296   0295             .ch1: 
0297   0295 23          	inc		hl
0298   0296 7E          	ld		a, (hl)
0299   0297 F6 20       	or		000100000b
0300   0299 11 C8 06    	ld		de, strHelp
0301   029C FE 3F       	cp		'?'
0302   029E CA 14 05    	jp z,	printErro
0303   02A1 FE 68       	cp		'h'
0304   02A3 CA 14 05    	jp z,	printErro
0305   02A6             
0306   02A6 0E 01       	ld		c, 1
0307   02A8 FE 65       	cp		'e'
0308   02AA 28 07       	jr z,	.achado
0309   02AC CB 21       	sla		c
0310   02AE FE 6C       	cp		'l'
0311   02B0 28 01       	jr z,	.achado
0312   02B2 C9          	ret
0313   02B3             .achado: 
0314   02B3 3A F6 09    	ld		a, (options)
0315   02B6 B1          	or		c
0316   02B7 32 F6 09    	ld		(options), a
0317   02BA C9          	ret
0318   02BB             
0319   02BB             ; ---------------------
0320   02BB             ; CHECK FILE
0321   02BB             ; CHECK IF FILE EXIST
0322   02BB             ; ---------------------
0323   02BB             checkFile: 
0324   02BB 11 62 08    	ld		de, strAbrirArq
0325   02BE CD 48 05    	call	print						; Open text
0326   02C1 3A F4 09    	ld		a, (dos)
0327   02C4 FE 02       	cp		2
0328   02C6 D2 D8 02    	jp nc,	.dos2						; DOS2 mode
0329   02C9             
0330   02C9 CD 4D 05    	call	makeFCB						; DOS1. Make FCB and Open command.
0331   02CC 21 49 0A    	ld		hl, fileNameDOS1
0332   02CF CD 5B 05    	call	buildFCB
0333   02D2 CD 64 05    	call	open						; Open. If file doesn't exist then error and exit.
0334   02D5 C3 0F 03    	jp		.p1
0335   02D8             
0336   02D8             .dos2: 									; DOS2 Open
0337   02D8 11 09 0A    	ld		de, fileNameDOS2
0338   02DB AF          	xor		a
0339   02DC 06 00       	ld		b, 0
0340   02DE 0E 43       	ld		c, _OPEN					; Open file DOS2
0341   02E0 CD 0C 05    	call	callBdos
0342   02E3 11 1A 08    	ld		de, strErroAbrirArq
0343   02E6 C2 14 05    	jp nz,	printErro					; if Z = 0 then file not found. Error and Exit
0344   02E9 78          	ld		a, b
0345   02EA 32 08 0A    	ld		(fileHandle), a				; Save FILE HANDLE
0346   02ED C5          	push	bc							; For check size in DOS 2, use SEEK Command.
0347   02EE 3E 02       	ld		a, SEEK_END
0348   02F0 11 00 00    	ld		de, 0
0349   02F3 21 00 00    	ld		hl, 0
0350   02F6 0E 4A       	ld		c, _SEEK					; Seek
0351   02F8 CD 0C 05    	call	callBdos
0352   02FB 22 68 0A    	ld		(sizefile), hl
0353   02FE ED 53 6A 0A 	ld		(sizefile+2), de
0354   0302 C1          	pop		bc
0355   0303 AF          	xor		a							; And Now Return Seek to POS 0 (SEEK_SET)
0356   0304 11 00 00    	ld		de, 0
0357   0307 21 00 00    	ld		hl, 0
0358   030A 0E 4A       	ld		c, _SEEK
0359   030C CD 0C 05    	call	callBdos
0360   030F             .p1: 
0361   030F 11 3F 08    	ld		de, strTamanhoErrado		; Test filesize. 128K = 00 00 02
0362   0312 3A 68 0A    	ld		a, (sizefile)
0363   0315 B7          	or		a
0364   0316 C2 14 05    	jp nz,	printErro
0365   0319 3A 69 0A    	ld		a, (sizefile+1)
0366   031C B7          	or		a
0367   031D C2 14 05    	jp nz,	printErro
0368   0320 3A 6A 0A    	ld		a, (sizefile+2)
0369   0323 FE 02       	cp		2
0370   0325 C2 14 05    	jp nz,	printErro
0371   0328 C9          	ret
0372   0329             
0373   0329             ; *** PROGRAM ROUTINES ***
0374   0329             
0375   0329             ; ----------------------------
0376   0329             ; LOADFILE
0377   0329             ; Load File into Flash
0378   0329             ; Load ALL FILE into Flash ROM
0379   0329             ; ----------------------------
0380   0329             loadFile: 
0381   0329 11 96 08    	ld		de, strGravando
0382   032C CD 48 05    	call	print						; Show Write Text
0383   032F 06 08       	ld		b, 8						; 8 blocks of 16K = 128K
0384   0331             .loop: 
0385   0331 C5          	push	bc
0386   0332 CD 85 03    	call	fillPage					; fill page 2 (read buffer) with $FF
0387   0335 CD 63 03    	call	load16K						; and load one 16 K page to buffer
0388   0338 C1          	pop		bc
0389   0339 C5          	push	bc
0390   033A CD 3A 04    	call	writeFlash					; now write this 16 K to FLASH
0391   033D FB          	ei
0392   033E 11 A3 08    	ld		de, strErroAoGravarFlash
0393   0341 C2 14 05    	jp nz,	printErro					; oops! Error writing bytes. Show Error and exit.
0394   0344             
0395   0344 11 94 08    	ld		de, strPonto
0396   0347 CD 48 05    	call	print						; show '*' for 16 K page loaded
0397   034A C1          	pop		bc
0398   034B 3A F8 09    	ld		a, (actualpage)
0399   034E 3C          	inc		a
0400   034F 32 F8 09    	ld		(actualpage), a				; and inc page to next loop
0401   0352 10 DD       	djnz	.loop						; next loop
0402   0354             
0403   0354 CD AE 05    	call	closeFile					; end for load. close File.
0404   0357 11 C5 06    	ld		de, strCrLf
0405   035A CD 48 05    	call	print
0406   035D 11 C9 08    	ld		de, strUpdateCompleto		; and print Success Text.
0407   0360 C3 48 05    	jp		print
0408   0363             
0409   0363             
0410   0363             ; ------------------
0411   0363             ; LOAD16K
0412   0363             ; Load 16K to frame 1
0413   0363             ; from file open
0414   0363             ; ------------------
0415   0363             load16K: 
0416   0363             	; this code load 16 KB from file
0417   0363             	; to buffer (frame 1: $4000 - $7FFF)
0418   0363             
0419   0363 FB          	ei
0420   0364 11 00 40    	ld		de, $4000					; buffer pointer = $4000
0421   0367 21 00 40    	ld		hl, $4000					; length = $4000 (16K)
0422   036A 3A F4 09    	ld		a, (dos)
0423   036D FE 02       	cp		2
0424   036F 30 0B       	jr nc,	.dos2						; if DOS 2 make <> load
0425   0371 E5          	push	hl							; DOS 1 LOAD.
0426   0372 CD A1 05    	call	setDTA						; set DTA
0427   0375 E1          	pop		hl
0428   0376 CD C6 05    	call	readMax						; and read 16 KB or max if file < 16K or file size
0429   0379 C3 A6 05    	jp		readFile					; is not mult. of 16. And READ.
0430   037C             .dos2: 									; DOS 2 LOAD
0431   037C 3A 08 0A    	ld		a, (fileHandle)
0432   037F 47          	ld		b, a
0433   0380 0E 48       	ld		c, _READ					; DOS 2 COMMAND Read
0434   0382 C3 04 05    	jp		callBdosCE
0435   0385             
0436   0385             ; --------------------
0437   0385             ; FILL PAGE
0438   0385             ; Fill page 1 with FFH
0439   0385             ; ---------------------
0440   0385             fillPage: 
0441   0385 21 00 40    	ld		hl, $4000
0442   0388 11 01 40    	ld		de, $4001
0443   038B 01 FF 3F    	ld		bc, $3FFF
0444   038E 36 FF       	ld		(hl), $FF
0445   0390 ED B0       	ldir								; fill
0446   0392 C9          	ret
0447   0393             
0448   0393             ; -----------------
0449   0393             ; FILLNAME
0450   0393             ; Search params for
0451   0393             ; extract fileName
0452   0393             ; -----------------
0453   0393             fillName: 
0454   0393 21 48 0A    	ld		hl, fileNameDOS2 + 63
0455   0396 06 40       	ld		b, 64						; max params. End to init loop
0456   0398             .loop: 
0457   0398 7E          	ld		a,(hl)
0458   0399 B7          	or		a
0459   039A 28 08       	jr z,	.p1							; 0 dec
0460   039C FE 3A       	cp		':'							; end
0461   039E 28 07       	jr z,	.p2
0462   03A0 FE 5C       	cp		'\\'						; params
0463   03A2 28 03       	jr z,	.p2
0464   03A4             .p1: 
0465   03A4 2B          	dec		hl
0466   03A5 10 F1       	djnz	.loop
0467   03A7             .p2: 
0468   03A7 23          	inc		hl
0469   03A8 11 70 08    	ld		de, strAbrirArq.nomearq		; loop for fill fileNameShow
0470   03AB             .loop2: 
0471   03AB 7E          	ld		a, (hl)
0472   03AC B7          	or		a
0473   03AD C8          	ret z
0474   03AE 12          	ld		(de),a
0475   03AF 23          	inc		hl
0476   03B0 13          	inc		de
0477   03B1 18 F8       	jr		.loop2
0478   03B3             
0479   03B3             ; ----------------------
0480   03B3             ; DELAY
0481   03B3             ; Flash operation delay
0482   03B3             ; ----------------------
0483   03B3             delay: 
0484   03B3 E5          	push	hl
0485   03B4 D5          	push	de
0486   03B5 C5          	push	bc							; this delay is for erasing operations
0487   03B6 3A 42 F3    	ld		a, (RAMAD1)
0488   03B9 26 40       	ld		h, $40
0489   03BB CD 24 00    	call	ENASLT						; set mem to page 1
0490   03BE 3A 02 0A    	ld		a, (erasedelay)				; loop times from delay.
0491   03C1 47          	ld		b, a
0492   03C2             .loop: 
0493   03C2 C5          	push	bc
0494   03C3 FB          	ei
0495   03C4 76          	halt
0496   03C5 F3          	di
0497   03C6 C1          	pop		bc
0498   03C7 10 F9       	djnz	.loop
0499   03C9 3A FA 09    	ld		a, (flashslt)
0500   03CC 26 40       	ld		h, $40
0501   03CE CD 24 00    	call	ENASLT						; return flash to page 1 (DOS1 Compatibility)
0502   03D1 FB          	ei
0503   03D2 C1          	pop		bc
0504   03D3 D1          	pop		de
0505   03D4 E1          	pop		hl
0506   03D5 C9          	ret
0507   03D6             
0508   03D6             ; -------------------------------------------------------
0509   03D6             ; SIGSLOT
0510   03D6             ; Returns in A the next slot every time it is called.
0511   03D6             ; For initializing purposes, thisslt has to be #FF.
0512   03D6             ; If no more slots, it returns A=#FF.
0513   03D6             ; this code is programmed by Nestor Soriano aka Konamiman
0514   03D6             ; --------------------------------------------------------
0515   03D6             sigslot: 
0516   03D6 3A F9 09    	ld		a, (thisslt)				; Returns the next slot, starting by
0517   03D9 FE FF       	cp		$FF							; slot 0. Returns #FF when there are not more slots
0518   03DB 20 09       	jr nz,	.p1							; Modifies AF, BC, HL.
0519   03DD 3A C1 FC    	ld		a, (EXPTBL)
0520   03E0 E6 80       	and		%10000000
0521   03E2 32 F9 09    	ld		(thisslt), a
0522   03E5 C9          	ret
0523   03E6             .p1: 
0524   03E6 3A F9 09    	ld		a, (thisslt)
0525   03E9 FE 8F       	cp		%10001111
0526   03EB 28 28       	jr z,	.nomaslt
0527   03ED FE 03       	cp		%00000011
0528   03EF 28 24       	jr z,	.nomaslt
0529   03F1 CB 7F       	bit		7, a
0530   03F3 20 12       	jr nz,	.sltexp
0531   03F5             .p2: 
0532   03F5 E6 03       	and		%00000011
0533   03F7 3C          	inc		a
0534   03F8 4F          	ld		c, a
0535   03F9 06 00       	ld		b, 0
0536   03FB 21 C1 FC    	ld		hl, EXPTBL
0537   03FE 09          	add		hl, bc
0538   03FF 7E          	ld		a, (hl)
0539   0400 E6 80       	and		%10000000
0540   0402 B1          	or		c
0541   0403 32 F9 09    	ld		(thisslt), a
0542   0406 C9          	ret
0543   0407             .sltexp: 
0544   0407 4F          	ld		c, a
0545   0408 E6 0C       	and		%00001100
0546   040A FE 0C       	cp		%00001100
0547   040C 79          	ld		a, c
0548   040D 28 E6       	jr z,	.p2
0549   040F C6 04       	add		a, %00000100
0550   0411 32 F9 09    	ld		(thisslt), a
0551   0414 C9          	ret
0552   0415             .nomaslt: 
0553   0415 3E FF       	ld		a, $FF
0554   0417 C9          	ret
0555   0418             
0556   0418             ; *** FLASH ROUTINES ***
0557   0418             
0558   0418             ; ----------------------
0559   0418             ; flashSendCommand
0560   0418             ; send command in A to 
0561   0418             ; flash mapped in page 2
0562   0418             ; Preserve flags
0563   0418             ; ----------------------
0564   0418             flashSendCommand: 
0565   0418 E5          	push	hl
0566   0419 F5          	push	af
0567   041A 3E 01       	ld		a, $01
0568   041C 32 00 70    	ld		($7000), a					; Selects bank 1
0569   041F 21 55 95    	ld		hl, $9555					; Write $AA to flash absolute address $5555
0570   0422 36 AA       	ld		(hl), $AA
0571   0424 3E 00       	ld		a, $00
0572   0426 32 00 70    	ld		($7000), a					; Selects bank 0
0573   0429 21 AA AA    	ld		hl, $AAAA					; Write $55 to flash absolute address $2AAA
0574   042C 36 55       	ld		(hl), $55
0575   042E 3E 01       	ld		a, $01
0576   0430 32 00 70    	ld		($7000), a					; Selects bank 1
0577   0433 21 55 95    	ld		hl, $9555					; Write command to flash absolute address $5555
0578   0436 F1          	pop		af
0579   0437 77          	ld		(hl), a
0580   0438 E1          	pop		hl
0581   0439 C9          	ret
0582   043A             
0583   043A             ; ----------------------
0584   043A             ; WRITEFLASH
0585   043A             ; Write 16 KB into Flash
0586   043A             ; page 1 : Flash
0587   043A             ; page 2 : Buffer
0588   043A             ; NZ = Error
0589   043A             ; ----------------------
0590   043A             writeFlash: 
0591   043A 3A FA 09    	ld		a, (flashslt)
0592   043D 26 80       	ld		h, $80
0593   043F CD 24 00    	call	ENASLT						; flash to page 2
0594   0442 3A FA 09    	ld		a, (flashslt)
0595   0445 26 40       	ld		h, $40
0596   0447 CD 24 00    	call	ENASLT						; flash to page 1
0597   044A 3A F8 09    	ld		a, (actualpage)
0598   044D             
0599   044D 32 00 70    	ld		($7000), a					; select 16K bank in frame 2
0600   0450 3A 42 F3    	ld		a, (RAMAD1)
0601   0453 26 40       	ld		h, $40
0602   0455 CD 24 00    	call	ENASLT						; mem to page 1
0603   0458 21 00 40    	ld		hl, $4000					; buffer pointer
0604   045B 11 00 80    	ld		de, $8000					; flash pointer
0605   045E 01 00 40    	ld		bc, $4000					; 16K
0606   0461 F3          	di
0607   0462             .loop: 
0608   0462 3E A0       	ld		a, $A0						; Modo de gravacao de dados
0609   0464 CD 18 04    	call	flashSendCommand
0610   0467 CD 87 04    	call	.gravaByte					; program byte
0611   046A 20 08       	jr nz,	.erro						; ERROR. Z = 0
0612   046C 23          	inc		hl							; Ok. Next byte.
0613   046D 13          	inc		de
0614   046E 0B          	dec		bc
0615   046F 78          	ld		a, b
0616   0470 B1          	or		c
0617   0471 C2 62 04    	jp nz,	.loop						; All 16 KB programmed? Return for making next block.
0618   0474             .erro: 
0619   0474 F5          	push	af
0620   0475 3A FA 09    	ld		a, (flashslt)
0621   0478 26 40       	ld		h, $40
0622   047A CD 24 00    	call	ENASLT						; flash to page 1
0623   047D 3A 42 F3    	ld		a, (RAMAD1)
0624   0480 26 40       	ld		h, $40
0625   0482 CD 24 00    	call	ENASLT						; Mem to PAGE 1 (DOS 1 Compatibility)
0626   0485 F1          	pop		af
0627   0486 C9          	ret
0628   0487             
0629   0487             ; program byte and check 30 times
0630   0487             .gravaByte: 
0631   0487 E5          	push	hl
0632   0488 D5          	push	de
0633   0489 C5          	push	bc
0634   048A 0E 1E       	ld		c, 30
0635   048C             .loop2: 									; write byte loop
0636   048C 7E          	ld		a, (hl)
0637   048D 12          	ld		(de), a
0638   048E             .loop3: 
0639   048E 00          	nop									; little delay
0640   048F 00          	nop
0641   0490 0D          	dec		c
0642   0491 1A          	ld		a, (de)
0643   0492 AE          	xor		(hl)
0644   0493 28 05       	jr z,	.fim						; ok programmed
0645   0495 79          	ld		a, c
0646   0496 B7          	or		a
0647   0497 20 F5       	jr nz,	.loop3
0648   0499 3C          	inc		a							; oops! Error
0649   049A             .fim: 
0650   049A C1          	pop		bc
0651   049B D1          	pop		de
0652   049C E1          	pop		hl
0653   049D C9          	ret
0654   049E             
0655   049E             ; -----------------------
0656   049E             ; ERASEFLASH
0657   049E             ; Sector Erase command
0658   049E             ; or CHIP Erase Command
0659   049E             ; -----------------------
0660   049E             eraseFlash: 
0661   049E 11 83 08    	ld		de, strApagarFlash
0662   04A1 CD 48 05    	call	print						; Erase Text Show.
0663   04A4 3A FA 09    	ld		a, (flashslt)
0664   04A7 26 40       	ld		h, $40
0665   04A9 CD 24 00    	call	ENASLT						; set flash in page 1
0666   04AC 3A FA 09    	ld		a, (flashslt)
0667   04AF 26 80       	ld		h, $80
0668   04B1 CD 24 00    	call	ENASLT						; and page 2
0669   04B4 F3          	di
0670   04B5 3E 80       	ld		a, $80						; Erase all command
0671   04B7 CD 18 04    	call	flashSendCommand
0672   04BA 3E 10       	ld		a, $10
0673   04BC CD 18 04    	call	flashSendCommand
0674   04BF 21 00 80    	ld		hl, $8000
0675   04C2 7E          	ld		a, (hl)
0676   04C3 32 03 0A    	ld		(togglebit), a
0677   04C6             .loop: 									; test finish by Toggle Bit
0678   04C6 3A 03 0A    	ld		a, (togglebit)
0679   04C9 BE          	cp		(hl)
0680   04CA 7E          	ld		a, (hl)
0681   04CB 32 03 0A    	ld		(togglebit), a
0682   04CE 20 F6       	jr nz,	.loop
0683   04D0 3E F0       	ld		a, $F0						; end command. Reset Command.
0684   04D2 CD 18 04    	call	flashSendCommand
0685   04D5 FB          	ei
0686   04D6 3A 42 F3    	ld		a, (RAMAD1)
0687   04D9 26 40       	ld		h, $40
0688   04DB CD 24 00    	call	ENASLT						; set mem to page 1
0689   04DE 3A 43 F3    	ld		a, (RAMAD2)
0690   04E1 26 80       	ld		h, $80
0691   04E3 CD 24 00    	call	ENASLT						; set mem to page 2
0692   04E6 11 FE 07    	ld		de, strOk
0693   04E9 CD 48 05    	call	print
0694   04EC 3A F6 09    	ld		a, (options)
0695   04EF CB 47       	bit		0, a						; check if /e command.
0696   04F1 C8          	ret	z								; No. Return to Main program
0697   04F2 C3 19 05    	jp		exitok						; Yes. Exit.
0698   04F5             
0699   04F5             
0700   04F5             ; *** GENERIC SYSTEM ROUTINES ***
0701   04F5             
0702   04F5             ; -------------
0703   04F5             ; CURSOR ON OFF
0704   04F5             ; -------------
0705   04F5             cursorOn: 
0706   04F5 3E 01       	ld		a, 1
0707   04F7             
0708   04F7             cursorSet: 
0709   04F7 32 A9 FC    	ld		(CSRSW), a
0710   04FA C9          	ret
0711   04FB             
0712   04FB             cursorOff: 
0713   04FB AF          	xor		a
0714   04FC 18 F9       	jr		cursorSet
0715   04FE             
0716   04FE             
0717   04FE             ; ----------------
0718   04FE             ; cmpHLcomDE
0719   04FE             ; Compares HL and DE
0720   04FE             ; BIOS RST 020H clone
0721   04FE             ; -----------------
0722   04FE             cmpHLcomDE: 
0723   04FE 7C          	ld		a, h
0724   04FF 92          	sub		d
0725   0500 C0          	ret		nz
0726   0501 7D          	ld		a, l
0727   0502 93          	sub		e
0728   0503 C9          	ret
0729   0504             
0730   0504             ; ---------------
0731   0504             ; BDOSCE
0732   0504             ; bdos with error
0733   0504             ; Call to BDOS and
0734   0504             ; check error
0735   0504             ; ----------------
0736   0504             callBdosCE: 
0737   0504 CD 05 00    	call	BDOS
0738   0507 B7          	or		a
0739   0508 C2 11 05    	jp nz,	error
0740   050B C9          	ret
0741   050C             
0742   050C             ; -----------------
0743   050C             ; BDOS
0744   050C             ; bdos without error
0745   050C             ; ------------------
0746   050C             callBdos: 
0747   050C CD 05 00    	call	BDOS
0748   050F B7          	or		a
0749   0510 C9          	ret
0750   0511             
0751   0511             ; -----------------------------------------------
0752   0511             ; ERROR
0753   0511             ; print error
0754   0511             ; call printErro and set DE pointer to error text
0755   0511             ; -----------------------------------------------
0756   0511             error: 
0757   0511 11 05 08    	ld		de, strErro
0758   0514             printErro: 
0759   0514 0E 09       	ld		c, _STROUT
0760   0516 CD 0C 05    	call	callBdos
0761   0519             
0762   0519             ; ---------------
0763   0519             ; EXITOK
0764   0519             ; Exit OK
0765   0519             ; ---------------
0766   0519             exitok: 
0767   0519 CD AE 05    	call	closeFile					; close file (open or not)
0768   051C 3A 42 F3    	ld		a, (RAMAD1)
0769   051F 26 40       	ld		h, $40
0770   0521 CD 24 00    	call	ENASLT						; set mem to page 1
0771   0524 3A 43 F3    	ld		a, (RAMAD2)
0772   0527 26 80       	ld		h, $80
0773   0529 CD 24 00    	call	ENASLT						; set mem to page 2
0774   052C 3A F5 09    	ld		a, (system)
0775   052F FE 03       	cp		3							; Turbo R?
0776   0531 38 06       	jr c,	exit						; No. Go To Exit
0777   0533 3A F2 09    	ld		a, (savecpu)				; Yes. Restore CPU Mode
0778   0536 CD 0E 02    	call	systemSetCPU
0779   0539             
0780   0539             ; ---------------
0781   0539             ; EXIT
0782   0539             ; program exit
0783   0539             ; ---------------
0784   0539             exit: 
0785   0539 3A F3 09    	ld		a,(savecursor)				; Restore Cursor Value
0786   053C CD F7 04    	call	cursorSet
0787   053F ED 7B F0 09 	ld		sp, (savesp)				; And Restore SP
0788   0543 0E 00       	ld		c, _TERM0					; Program Terminate BDOS Command.
0789   0545 C3 0C 05    	jp		callBdos					; Go and Exit. WOW!
0790   0548             
0791   0548             ; *** BDOS ROUTINES ***
0792   0548             
0793   0548             ; -------------------
0794   0548             ; PRINT
0795   0548             ; DE : Pointer to Text
0796   0548             ; --------------------
0797   0548             print: 
0798   0548 0E 09       	ld		c, _STROUT
0799   054A C3 0C 05    	jp		callBdos
0800   054D             
0801   054D             ; ----------------
0802   054D             ; makeFCB
0803   054D             ; Prepare NEW FCB
0804   054D             ; ---------------
0805   054D             makeFCB: 
0806   054D 21 58 0A    	ld		hl, FCB
0807   0550 11 59 0A    	ld		de, FCB+1
0808   0553 36 00       	ld		(hl), 0
0809   0555 01 25 00    	ld		bc, 37
0810   0558 ED B0       	ldir
0811   055A C9          	ret
0812   055B             
0813   055B             ; -------------
0814   055B             ; buildFCB
0815   055B             ; HL = Pointer to namefile string
0816   055B             ; ----------------
0817   055B             buildFCB: 
0818   055B 11 59 0A    	ld		de, fileName
0819   055E 01 0B 00    	ld		bc, 11
0820   0561 ED B0       	ldir
0821   0563 C9          	ret
0822   0564             
0823   0564             ; ---------------
0824   0564             ; OPEN FCB FILE
0825   0564             ; ---------------
0826   0564             open: 
0827   0564 11 58 0A    	ld		de, FCB
0828   0567 0E 0F       	ld		c, _FOPEN
0829   0569 CD 0C 05    	call	callBdos
0830   056C 11 1A 08    	ld		de, strErroAbrirArq
0831   056F C2 14 05    	jp nz,	printErro
0832   0572 DD 21 58 0A 	ld		ix, FCB
0833   0576 3E 01       	ld		a, 1
0834   0578 DD 77 0E    	ld		(ix+14), a
0835   057B AF          	xor		a
0836   057C DD 77 0F    	ld		(ix+15), a
0837   057F DD 36 21 00 	ld		(ix+33), 0
0838   0583 DD 36 22 00 	ld		(ix+34), 0
0839   0587 DD 36 23 00 	ld		(ix+35), 0
0840   058B DD 36 24 00 	ld		(ix+36), 0
0841   058F C9          	ret
0842   0590             
0843   0590             ; --------------
0844   0590             ; SEEK
0845   0590             ; DEHL = Pointer
0846   0590             ; --------------
0847   0590             seek: 
0848   0590 DD 21 58 0A 	ld		ix, FCB
0849   0594 DD 75 21    	ld		(ix+33), l
0850   0597 DD 74 22    	ld		(ix+34), h
0851   059A DD 73 23    	ld		(ix+35), e
0852   059D DD 72 24    	ld		(ix+36), d
0853   05A0 C9          	ret
0854   05A1             
0855   05A1             ; ------------
0856   05A1             ; setDTA
0857   05A1             ; DE = Buffer
0858   05A1             ; ------------
0859   05A1             setDTA: 
0860   05A1 0E 1A       	ld		c, _SETDTA
0861   05A3 C3 0C 05    	jp		callBdos
0862   05A6             
0863   05A6             ; -------------------------------------------------------
0864   05A6             ; READ
0865   05A6             ; HL Bytes to read from opened FCB, with the pointer ready
0866   05A6             ; -------------------------------------------------------
0867   05A6             readFile: 
0868   05A6 11 58 0A    	ld		de, FCB
0869   05A9 0E 27       	ld		c, _RDBLK
0870   05AB C3 04 05    	jp		callBdosCE
0871   05AE             
0872   05AE             ; ----------------
0873   05AE             ; closeFile
0874   05AE             ; close FCB FILE
0875   05AE             ; close File. Check DOS variable for DOS2 and DOS1 close
0876   05AE             ; ----------------
0877   05AE             closeFile: 
0878   05AE 3A F4 09    	ld		a, (dos)
0879   05B1 FE 02       	cp		2
0880   05B3 30 08       	jr nc,	.dos2
0881   05B5 11 58 0A    	ld		de, FCB
0882   05B8 0E 10       	ld		c, _FCLOSE
0883   05BA C3 0C 05    	jp		callBdos
0884   05BD             .dos2: 
0885   05BD 3A 08 0A    	ld		a, (fileHandle)
0886   05C0 47          	ld		b, a
0887   05C1 0E 45       	ld		c, _CLOSE
0888   05C3 C3 0C 05    	jp		callBdos
0889   05C6             
0890   05C6             ; -------------------------
0891   05C6             ; READ MAX
0892   05C6             ; HL : Size to read
0893   05C6             ; Returns HL max size
0894   05C6              ; this code is for DOS1 Compatibility
0895   05C6              ; In DOS2 if HL parameter (Read Size) > Size File or Bytes to read
0896   05C6              ; Do not Return ERROR
0897   05C6              ; But DOS1 RETURN ERROR
0898   05C6              ; The Load16K Code USES HL = 16384 bytes ALWAYS.
0899   05C6             ; -------------------------
0900   05C6             readMax: 
0901   05C6 F5          	push	af
0902   05C7 D5          	push	de
0903   05C8 E5          	push	hl
0904   05C9 AF          	xor		a
0905   05CA 2A 6A 0A    	ld		hl, (sizefile+2)
0906   05CD ED 5B 7B 0A 	ld		de, (sizeread+2)
0907   05D1 ED 52       	sbc		hl, de
0908   05D3 22 06 0A    	ld		(sizefiletmp+2), hl
0909   05D6 2A 68 0A    	ld		hl, (sizefile)
0910   05D9 ED 5B 79 0A 	ld		de, (sizeread)
0911   05DD ED 52       	sbc		hl, de
0912   05DF 22 04 0A    	ld		(sizefiletmp), hl
0913   05E2 E1          	pop		hl
0914   05E3 E5          	push	hl
0915   05E4 ED 5B 04 0A 	ld		de, (sizefiletmp)
0916   05E8 CD FE 04    	call	cmpHLcomDE
0917   05EB 30 04       	jr nc,	.readmax0
0918   05ED E1          	pop		hl
0919   05EE             .readmaxend: 
0920   05EE D1          	pop		de
0921   05EF F1          	pop		af
0922   05F0 C9          	ret
0923   05F1             .readmax0: 
0924   05F1 ED 5B 06 0A 	ld		de, (sizefiletmp+2)
0925   05F5 21 00 00    	ld		hl, 0
0926   05F8 CD FE 04    	call	cmpHLcomDE
0927   05FB E1          	pop		hl
0928   05FC 20 F0       	jr nz,	.readmaxend
0929   05FE             .readmax1: 
0930   05FE 2A 04 0A    	ld		hl, (sizefiletmp)
0931   0601 18 EB       	jr		.readmaxend
0932   0603             
0933   0603             ; ----------------------
0934   0603             ; ShowList
0935   0603             ; Exibe a lista de flashs
0936   0603             ; suportadas
0937   0603             ; ----------------------
0938   0603             showList: 
0939   0603 11 EB 08    	ld		de, strListaCab
0940   0606 CD 48 05    	call	print
0941   0609 21 2E 09    	ld		hl, tblFlash				; HL points to table start
0942   060C             .loop: 
0943   060C 7E          	ld		a, (hl)
0944   060D FE 00       	cp		0							; no more entries?
0945   060F CA 39 05    	jp z,	exit
0946   0612 32 FB 09    	ld		(flashIdMan), a				; save manufacturer ID
0947   0615 23          	inc		hl
0948   0616 7E          	ld		a, (hl)						; get product ID
0949   0617 32 FC 09    	ld		(flashIdProd), a			; save it
0950   061A 23          	inc		hl
0951   061B 5E 23 56 2B 	ld		de, (hl)					; Get string pointer of manufacturer
0952   061F ED 53 FE 09 	ld		(flashManPoint), de			; save it
0953   0623 23          	inc		hl
0954   0624 23          	inc		hl
0955   0625 5E 23 56 2B 	ld		de, (hl)					; Get string pointer of product
0956   0629 ED 53 00 0A 	ld		(flashProdPoint), de		; save it
0957   062D 23          	inc		hl
0958   062E 23          	inc		hl
0959   062F 7E          	ld		a, (hl)						; Get algorythm
0960   0630 32 FD 09    	ld		(flashAlg), a
0961   0633 23          	inc		hl
0962   0634 E5          	push	hl
0963   0635 ED 5B FE 09 	ld		de, (flashManPoint)
0964   0639 CD 48 05    	call	print
0965   063C ED 5B 00 0A 	ld		de, (flashProdPoint)
0966   0640 CD 48 05    	call	print
0967   0643 11 C5 06    	ld		de, strCrLf
0968   0646 CD 48 05    	call	print
0969   0649 E1          	pop		hl
0970   064A 18 C0       	jr		.loop
0971   064C C9          	ret
0972   064D             
0973   064D             ; ----------------------
0974   064D             ; FlashIdent
0975   064D             ; Identifies Flash
0976   064D             ; ----------------------
0977   064D             flashIdent: 
0978   064D E5          	push	hl
0979   064E C5          	push	bc
0980   064F D5          	push	de
0981   0650 21 2E 09    	ld		hl, tblFlash				; HL points to table start
0982   0653 3A FB 09    	ld		a, (flashIdMan)
0983   0656 47          	ld		b, a						; Manufacturer ID in B
0984   0657 16 00       	ld		d, 0
0985   0659             .loop: 
0986   0659 7E          	ld		a, (hl)
0987   065A FE 00       	cp		0							; no more entries?
0988   065C 28 2D       	jr z,	.naoId						; nop, unsucessfull!
0989   065E B8          	cp		b							; compares manufacturer ID
0990   065F 28 05       	jr z,	.idp						; Ok, detects product ID
0991   0661 1E 07       	ld		e, 7
0992   0663 19          	add		hl, de						; no matches, next entry
0993   0664 18 F3       	jr		.loop
0994   0666             .idp: 
0995   0666 23          	inc		hl							; compares product ID
0996   0667 3A FC 09    	ld		a, (flashIdProd)
0997   066A BE          	cp		(hl)						; equal?
0998   066B 28 05       	jr z,	.ok							; Yes, sucessful
0999   066D 1E 06       	ld		e, 6
1000   066F 19          	add		hl, de						; no matches, next entry
1001   0670 18 E7       	jr		.loop
1002   0672             .ok: 
1003   0672 23          	inc		hl
1004   0673 5E 23 56 2B 	ld		de, (hl)
1005   0677 ED 53 FE 09 	ld		(flashManPoint), de
1006   067B 23          	inc		hl
1007   067C 23          	inc		hl
1008   067D 5E 23 56 2B 	ld		de, (hl)
1009   0681 ED 53 00 0A 	ld		(flashProdPoint), de
1010   0685 23          	inc		hl
1011   0686 23          	inc		hl
1012   0687 7E          	ld		a, (hl)
1013   0688 32 FD 09    	ld		(flashAlg), a
1014   068B             .naoId: 
1015   068B D1          	pop		de
1016   068C C1          	pop		bc
1017   068D E1          	pop		hl
1018   068E C9          	ret
1019   068F             
1020   068F             ; *** TEXTS ***
1021   068F             
1022   068F             strTitulo: 
1023   068F             	.db		"SD Mapper flash programmer utility"
1023   068F 5344204D617070657220666C6173682070726F6772616D6D6572207574696C69
1023   06AF 7479
1024   06B1 0D 0A       	.db		13, 10
1025   06B3             	.db		"(c) 2014 by FBLabs"
1025   06B3 28632920323031342062792046424C616273
1026   06C5             	; fall throw
1027   06C5             
1028   06C5             strCrLf: 
1029   06C5 0D 0A 24    	.db		13, 10, '$'
1030   06C8             
1031   06C8             strHelp: 
1032   06C8 0D 0A       	.db		13, 10
1033   06CA             	.db		"Usage:", 13, 10
1033   06CA 55736167653A0D0A
1034   06D2             	.db		"     sdmupd /opts <filename.ext>", 13, 10
1034   06D2 202020202073646D757064202F6F707473203C66696C656E616D652E6578743E
1034   06F2 0D0A
1035   06F4             	.db		"Example: sdmupd DRIVER.ROM", 13, 10
1035   06F4 4578616D706C653A2073646D757064204452495645522E524F4D0D0A
1036   0710             	.db		"         sdmupd /e", 13, 10
1036   0710 20202020202020202073646D757064202F650D0A
1037   0724 0D 0A       	.db		13, 10
1038   0726             	.db		"Options:", 13, 10
1038   0726 4F7074696F6E733A0D0A
1039   0730             	.db		"     /h : Show this help.", 13, 10
1039   0730 20202020202F68203A2053686F7720746869732068656C702E0D0A
1040   074B             	.db		"     /l : Show list of supported chips.", 13, 10
1040   074B 20202020202F6C203A2053686F77206C697374206F6620737570706F72746564
1040   076B 2063686970732E0D0A
1041   0774             	.db		"     /e : Only erase flash and exit.", 13, 10
1041   0774 20202020202F65203A204F6E6C7920657261736520666C61736820616E642065
1041   0794 7869742E0D0A
1042   079A 24          	.db		'$'
1043   079B             
1044   079B             strProcuraFlash: 
1045   079B             	.db		"Searching SD Mapper in system ...", 13, 10
1045   079B 536561726368696E67205344204D617070657220696E2073797374656D202E2E
1045   07BB 2E0D0A
1046   07BE 24          	.db		'$'
1047   07BF             
1048   07BF             strNaoAchado: 
1049   07BF             	.db		"Oops! SD Mapper not Found!!", 13, 10
1049   07BF 4F6F707321205344204D6170706572206E6F7420466F756E6421210D0A
1050   07DC 24          	.db		'$'
1051   07DD             
1052   07DD             strAchado: 
1053   07DD             	.db		"Found in slot "
1053   07DD 466F756E6420696E20736C6F7420
1054   07EB             .slot
1055   07EB              
1056   07EB 30          	.db		'0'
1057   07EC             	.db		" subslot "
1057   07EC 20737562736C6F7420
1058   07F5             .subslot: 
1059   07F5 30 3A 0D 0A 	.db		'0:', 13, 10
1060   07F9 24          	.db		'$'
1061   07FA             
1062   07FA             strTraco: 
1063   07FA 20 2D 20 24 	.db		" - $"
1064   07FE             
1065   07FE             strOk: 
1066   07FE             	.db		" OK!", 13, 10
1066   07FE 204F4B210D0A
1067   0804 24          	.db		'$'
1068   0805             
1069   0805             strErro: 
1070   0805 0D 0A       	.db		13, 10
1071   0807             	.db		"ERROR (BDOS)!!!!", 13, 10
1071   0807 4552524F52202842444F5329212121210D0A
1072   0819 24          	.db		'$'
1073   081A             
1074   081A             strErroAbrirArq: 
1075   081A 0D 0A       	.db		13, 10
1076   081C             	.db		"ERROR: Problems opening file ...", 13, 10
1076   081C 4552524F523A2050726F626C656D73206F70656E696E672066696C65202E2E2E
1076   083C 0D0A
1077   083E 24          	.db		'$'
1078   083F             
1079   083F             strTamanhoErrado: 
1080   083F 0D 0A       	.db		13, 10
1081   0841             	.db		"ERROR: File size must be 128KB"
1081   0841 4552524F523A2046696C652073697A65206D757374206265203132384B42
1082   085F 0D 0A 24    	.db		13, 10, '$'
1083   0862             
1084   0862             strAbrirArq: 
1085   0862 0D 0A       	.db		13, 10
1086   0864             	.db		"Open file : "
1086   0864 4F70656E2066696C65203A20
1087   0870             .nomearq: 
1088   0870             	.db		"                "
1088   0870 20202020202020202020202020202020
1089   0880 0D 0A 24    	.db		13, 10, '$'
1090   0883             
1091   0883             strApagarFlash: 
1092   0883 0D 0A       	.db		13, 10
1093   0885             	.db		"Erasing Flash "
1093   0885 45726173696E6720466C61736820
1094   0893 24          	.db		'$'
1095   0894             
1096   0894             strPonto: 
1097   0894 2A 24       	.db		'*$'
1098   0896             
1099   0896             strGravando: 
1100   0896 0D 00 0A 00 	.dw 	13, 10
1101   089A             	.db		"Loading "
1101   089A 4C6F6164696E6720
1102   08A2 24          	.db 	'$'
1103   08A3             
1104   08A3             strErroAoGravarFlash: 
1105   08A3 0D 0A       	.db		13, 10
1106   08A5             	.db		"ERROR: Problems writing Flash ...", 13, 10
1106   08A5 4552524F523A2050726F626C656D732077726974696E6720466C617368202E2E
1106   08C5 2E0D0A
1107   08C8 24          	.db		'$'
1108   08C9             
1109   08C9             strUpdateCompleto: 
1110   08C9 0D 0A       	.db		13, 10
1111   08CB             	.db		"Flash programmed succesfully.", 13, 10
1111   08CB 466C6173682070726F6772616D6D65642073756363657366756C6C792E0D0A
1112   08EA 24          	.db		'$'
1113   08EB             
1114   08EB             strListaCab: 
1115   08EB 0D 0A       	.db		13, 10
1116   08ED             	.db		"List of supported flash chips:", 13, 10
1116   08ED 4C697374206F6620737570706F7274656420666C6173682063686970733A0D0A
1117   090D             	.db		"------------------------------", 13, 10
1117   090D 2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D0D0A
1118   092D 24          	.db		'$'
1119   092E             
1120   092E             ; *** TABLES ***
1121   092E             ; AT49F002    = $1F $07		alg byte
1122   092E             ; AT49F002T   = $1F $08		alg byte
1123   092E             ; AT49(H)F010 = $1F $17		alg byte
1124   092E             ; AT29C010A   = $1F $D5		alg 128-page
1125   092E             ; AM29F010    = $01 $20		alg byte
1126   092E             ; SST29EE010  = $BF $07		alg 128-page
1127   092E             ; SST39SF020  = $BF $B6		alg byte
1128   092E             ; W49F002U/N  = $DA $0B		alg byte
1129   092E             ; W49F002B    = $DA $25		alg byte
1130   092E             ; W39F010     = $DA $A1		alg byte
1131   092E             ; 
1132   092E             
1133   092E             tblFlash: 
1134   092E 1F 07       	.db		$1F, $07
1135   0930 75 09       		.dw strAtmel
1136   0932 8F 09       		.dw strAt49f002
1137   0934 01          		.db ALG_BYTE
1138   0935 1F 08       	.db		$1F, $08
1139   0937 75 09       		.dw strAtmel
1140   0939 98 09       		.dw	strAt49F002t
1141   093B 01          		.db ALG_BYTE
1142   093C 1F 17       	.db		$1F, $17
1143   093E 75 09       		.dw strAtmel
1144   0940 A2 09       		.dw	strAt49f010
1145   0942 01          		.db ALG_BYTE
1146   0943 1F D5       	.db		$1F, $D5
1147   0945 75 09       		.dw strAtmel
1148   0947 AB 09       		.dw strAt29c010a
1149   0949 02          		.db ALG_PAGE
1150   094A 01 20       	.db		$01, $20
1151   094C 7C 09       		.dw strAMD
1152   094E B5 09       		.dw	strAm29F010
1153   0950 01          		.db	ALG_BYTE
1154   0951 BF 07       	.db		$BF, $07
1155   0953 81 09       		.dw	strSST
1156   0955 BE 09       		.dw	strSst29ee010
1157   0957 02          		.db	ALG_PAGE
1158   0958 BF B6       	.db		$BF, $B6
1159   095A 81 09       		.dw	strSST
1160   095C C9 09       		.dw	strSst39sf020
1161   095E 01          		.db	ALG_BYTE
1162   095F DA 0B       	.db		$DA, $0B
1163   0961 86 09       		.dw	strWinb
1164   0963 D4 09       		.dw	strW49f002un
1165   0965 01          		.db	ALG_BYTE
1166   0966 DA 25       	.db		$DA, $25
1167   0968 86 09       		.dw	strWinb
1168   096A DF 09       		.dw	strW49f002b
1169   096C 01          		.db	ALG_BYTE
1170   096D DA A1       	.db		$DA, $A1
1171   096F 86 09       		.dw	strWinb
1172   0971 E8 09       		.dw	strW39f010
1173   0973 01          		.db	ALG_BYTE
1174   0974 00          	.db		0
1175   0975             
1176   0975             strAtmel: 
1177   0975             	.db		"Atmel $"
1177   0975 41746D656C2024
1178   097C             strAMD: 
1179   097C 414D442024  	.db		"AMD $"
1180   0981             strSST: 
1181   0981 5353542024  	.db		"SST $"
1182   0986             strWinb: 
1183   0986             	.db		"Winbond $"
1183   0986 57696E626F6E642024
1184   098F             strAt49f002: 
1185   098F             	.db		"AT49F002$"
1185   098F 415434394630303224
1186   0998             strAt49F002t: 
1187   0998             	.db		"AT49F002T$"
1187   0998 41543439463030325424
1188   09A2             strAt49f010: 
1189   09A2             	.db		"AT49F010$"
1189   09A2 415434394630313024
1190   09AB             strAt29c010a: 
1191   09AB             	.db		"AT29C010A$"
1191   09AB 41543239433031304124
1192   09B5             strAm29F010: 
1193   09B5             	.db		"AM29F010$"
1193   09B5 414D32394630313024
1194   09BE             strSst29ee010: 
1195   09BE             	.db		"SST29EE010$"
1195   09BE 5353543239454530313024
1196   09C9             strSst39sf020: 
1197   09C9             	.db		"SST39SF020$"
1197   09C9 5353543339534630323024
1198   09D4             strW49f002un: 
1199   09D4             	.db		"W49F002U/N$"
1199   09D4 57343946303032552F4E24
1200   09DF             strW49f002b: 
1201   09DF             	.db		"W49F002B$"
1201   09DF 573439463030324224
1202   09E8             strW39f010: 
1203   09E8             	.db		"W39F010$"
1203   09E8 5733394630313024
1204   09F0             
1205   09F0             ; *** VARIABLES ***
1206   09F0             
1207   09F0 00 00       savesp: 			.dw	0					; stack pointer
1208   09F2 00          savecpu: 		.db	0					; cpu mode in Turbo R
1209   09F3 00          savecursor: 		.db	0					; cursor
1210   09F4 00          dos: 			.db	0					; dos version
1211   09F5 00          system: 			.db	0					; msx version
1212   09F6 00          options: 		.db	0					; options variable 1
1213   09F7 00          pages: 			.db	0					; 16 Kb Pages
1214   09F8 00          actualpage: 		.db	0					; Temporal page for load
1215   09F9 FF          thisslt: 		.db	0FFh				; sigslot flag
1216   09FA 00          flashslt: 		.db	0					; slot for flash
1217   09FB 00          flashIdMan: 		.db 0					; Flash Manufacturer ID
1218   09FC 00          flashIdProd: 	.db 0					; Flash Product ID
1219   09FD 00          flashAlg		.db 0					; Flash algorithm
1220   09FE 00 00       flashManPoint: 	.dw 0					; Flash manufacturer string pointer
1221   0A00 00 00       flashProdPoint: 	.dw	0					; Flash product string pointer
1222   0A02 00          erasedelay: 		.db	0					; tmp variable for loop times delay
1223   0A03 00          togglebit: 		.db 0
1224   0A04 00          sizefiletmp: 	.ds	4					; tmp variable for READMAX Code
1225   0A08 00          fileHandle: 		.db	0					; DOS 2 File Handle
1226   0A09 00          fileNameDOS2: 	.ds	64					; Tmp for fileName
1227   0A49             fileNameDOS1: 	.db "        "			; DOS1 fileName for DOS1 Code
1227   0A49 2020202020202020
1228   0A51 20 20 20    filenDOS1Ext: 	.db	"   "
1229   0A54 00          				.ds	4
1230   0A58             
1231   0A58             ; *** FCB DOS 1 ***
1232   0A58             FCB: 
1233   0A58 00          unidad: 		.db	0
1234   0A59 00          fileName: 	.ds	8
1235   0A61 00          extname: 	.ds	3
1236   0A64 00 00       			.dw	0
1237   0A66 00 00       registro: 	.dw	0
1238   0A68 00          sizefile: 	.ds	4
1239   0A6C 00          			.ds	13
1240   0A79             sizeread: 
1241   0A79 00          			.ds	4
1242   0A7D 00          			.db	0
1243   0A7E             
