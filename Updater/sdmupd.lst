0001   0000             ; Projeto MSX SD Mapper
0002   0000             
0003   0000             ; Copyright (c) 2014
0004   0000             ; Fabio Belavenuto
0005   0000             ;
0006   0000             ; Baseado no código FL2 versão 2.2 de 29-12-2002  (c) Ramones 2002
0007   0000             ;
0008   0000             ;
0009   0000             ; This documentation describes Open Hardware and is licensed under the CERN OHL v. 1.1.
0010   0000             ; You may redistribute and modify this documentation under the terms of the
0011   0000             ; CERN OHL v.1.1. (http://ohwr.org/cernohl). This documentation is distributed
0012   0000             ; WITHOUT ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING OF MERCHANTABILITY,
0013   0000             ; SATISFACTORY QUALITY AND FITNESS FOR A PARTICULAR PURPOSE.
0014   0000             ; Please see the CERN OHL v.1.1 for applicable conditions
0015   0000             
0016   0000             
0017   0000             	output	"sdmupd.com"
0018   0000             
0019   0000             	include	"bios.inc"
0001+  0000             ;
0002+  0000             ; BIOS definitions
0003+  0000             ;
0004+  0000             
0005+  0000             PSLTRG			= $A8			; I/O port address of primary slot register
0006+  0000             
0007+  0000             WBOOT			= $00
0008+  0000             RDSLT			= $0C
0009+  0000             WRSLT			= $14
0010+  0000             CALSTL			= $1C
0011+  0000             ENASLT			= $24
0012+  0000             IDBYT0			= $2B
0013+  0000             BASVER			= $2D
0014+  0000             CALLF			= $30
0015+  0000             KEYINT			= $38
0016+  0000             WRTVDP			= $47
0017+  0000             LDIRMV			= $59
0018+  0000             LDIRVM			= $5C
0019+  0000             CHGMOD			= $5F
0020+  0000             INITXT			= $6C
0021+  0000             CHSNS			= $9C
0022+  0000             CHGET			= $9F
0023+  0000             CHPUT			= $A2
0024+  0000             LPTOUT			= $A5
0025+  0000             BREAKX			= $B7
0026+  0000             CKCNTC			= $BD
0027+  0000             ERAFNK			= $CC
0028+  0000             TOTEXT			= $D2
0029+  0000             SNSMAT			= $141
0030+  0000             PHYDIO			= $144
0031+  0000             KILBUF			= $156
0032+  0000             CALBAS			= $159
0033+  0000             EXTROM			= $15F
0034+  0000             
0035+  0000             RDPRIM			= $F380
0036+  0000             WRPRIM			= $F385
0037+  0000             CLPRIM			= $F38C
0038+  0000             CLPRM1			= $F398
0039+  0000             LINL40			= $F3AE
0040+  0000             LINLEN			= $F3B0
0041+  0000             CNSDFG			= $F3DE
0042+  0000             LPTPOS			= $F415
0043+  0000             PRTFLG			= $F416
0044+  0000             CURLIN			= $F41C
0045+  0000             KBUF			= $F41F
0046+  0000             BUF				= $F55E
0047+  0000             TTYPOS			= $F661
0048+  0000             VALTYP			= $F663
0049+  0000             MEMSIZ			= $F672
0050+  0000             STKTOP			= $F674
0051+  0000             TXTTAB			= $F676
0052+  0000             TEMPPT			= $F678
0053+  0000             TEMPST			= $F67A
0054+  0000             DSCTMP			= $F698
0055+  0000             FRETOP			= $F69B
0056+  0000             AUTLIN			= $F6AB
0057+  0000             SAVSTK			= $F6B1
0058+  0000             VARTAB			= $F6C2
0059+  0000             STREND			= $F6C6
0060+  0000             DAC				= $F7F6
0061+  0000             ARG				= $F847
0062+  0000             MAXFIL			= $F85F
0063+  0000             FILTAB			= $F860
0064+  0000             NULBUF			= $F862
0065+  0000             PTRFIL			= $F864
0066+  0000             FILNAM			= $F866
0067+  0000             NLONLY			= $F87C
0068+  0000             SAVEND			= $F87D
0069+  0000             EXBRSA			= $FAF0
0070+  0000             HOKVLD			= $FB20
0071+  0000             YFB21			= $FB21					; diskdriver table
0072+  0000             DRVINV			= $FB22					; Installed Disk-ROM
0073+  0000             YFB29			= $FB29					; diskdriver interrupt table
0074+  0000             BOTTOM			= $FC48
0075+  0000             HIMEM			= $FC4A
0076+  0000             CSRSW			= $FCA9
0077+  0000             FLBMEM			= $FCAE
0078+  0000             RUNBNF			= $FCBE
0079+  0000             SAVENT			= $FCBF
0080+  0000             EXPTBL			= $FCC1					; slots expanded or not
0081+  0000             SLTTBL			= $FCC5
0082+  0000             SLTATR			= $FCC9
0083+  0000             SLTWRK			= $FD09
0084+  0000             PROCNM			= $FD89
0085+  0000             DEVICE			= $FD99
0086+  0000             H.TIMI			= $FD9F
0087+  0000             H.KEYI			= $FD9A					; interrupt hook
0088+  0000             H.DSKO			= $FDEF
0089+  0000             H.NAME			= $FDF9
0090+  0000             H.KILL			= $FDFE
0091+  0000             H.COPY			= $FE08
0092+  0000             H.DSKF			= $FE12
0093+  0000             H.DSKI			= $FE17
0094+  0000             H.LSET			= $FE21
0095+  0000             H.RSET			= $FE26
0096+  0000             H.FIEL			= $FE2B
0097+  0000             H.MKI			= $FE30
0098+  0000             H.MKS			= $FE35
0099+  0000             H.MKD			= $FE3A
0100+  0000             H.CVI			= $FE3F
0101+  0000             H.CVS			= $FE44
0102+  0000             H.CVD			= $FE49
0103+  0000             H.GETP			= $FE4E
0104+  0000             H.NOFO			= $FE58
0105+  0000             H.NULO			= $FE5D
0106+  0000             H.NTFL			= $FE62
0107+  0000             H.BINS			= $FE71
0108+  0000             H.BINL			= $FE76
0109+  0000             H.FILE			= $FE7B
0110+  0000             H.DGET			= $FE80
0111+  0000             H.FILO			= $FE85
0112+  0000             H.INDS			= $FE8A
0113+  0000             H.LOC			= $FE99
0114+  0000             H.LOF			= $FE9E
0115+  0000             H.EOF			= $FEA3
0116+  0000             H.BAKU			= $FEAD
0117+  0000             H.PARD			= $FEB2
0118+  0000             H.NODE			= $FEB7
0119+  0000             H.POSD			= $FEBC
0120+  0000             H.RUNC			= $FECB
0121+  0000             H.CLEA			= $FED0
0122+  0000             H.LOPD			= $FED5
0123+  0000             H.STKE			= $FEDA
0124+  0000             H.ERRP			= $FEFD
0125+  0000             H.PHYD			= $FFA7
0126+  0000             H.FORM			= $FFAC
0127+  0000             EXTBIO			= $FFCA
0128+  0000             DISINT			= $FFCF
0129+  0000             ENAINT			= $FFD4
0130+  0000             EXTVDP			= $FFE7
0131+  0000             
0020   0000             	include	"bdos.inc"
0001+  0000             ;
0002+  0000             ; MSX-DOS definitions
0003+  0000             ;
0004+  0000             
0005+  0000             BDOS			= 5
0006+  0000             
0007+  0000             	MACRO BdosCall function
0008+  0000~            		ld		c, function
0009+  0000~            		call	BDOS
0010+  0000             	ENDM
0011+  0000             
0012+  0000             _TERM0			= $00					; Program terminate
0013+  0000             _CONIN			= $01					; Console input
0014+  0000             _CONOUT			= $02					; Console output
0015+  0000             _AUXIN			= $03					; Auxiliary input
0016+  0000             _AUXOUT			= $04					; Auxiliary output
0017+  0000             _LSTOUT			= $05					; Printer output
0018+  0000             _DIRIO			= $06					; Direct console I/O
0019+  0000             _DIRIN			= $07					; Direct console input
0020+  0000             _INNOE			= $08					; Console input without echo
0021+  0000             _STROUT			= $09					; String output
0022+  0000             _BUFIN			= $0A					; Buffered line input
0023+  0000             _CONST			= $0B					; Console status
0024+  0000             _CPMVER			= $0C					; Return version number
0025+  0000             _DSKRST			= $0D					; Disk reset
0026+  0000             _SELDSK			= $0E					; Select disk
0027+  0000             _FOPEN			= $0F					; Open file
0028+  0000             _FCLOSE			= $10					; Close file
0029+  0000             _SFIRST			= $11					; Search for first
0030+  0000             _SNEXT			= $12					; Search for next
0031+  0000             _FDEL			= $13					; Delete file
0032+  0000             _RDSEQ			= $14					; Sequencial read
0033+  0000             _WRSEQ			= $15					; Sequencial write
0034+  0000             _FMAKE			= $16					; Create file
0035+  0000             _FREN			= $17					; Rename file
0036+  0000             _LOGIN          = $18					; Get login vector
0037+  0000             _CURDRV			= $19					; Get current drive
0038+  0000             _SETDTA			= $1A					; Set disk transfer address
0039+  0000             _ALLOC			= $1B					; Get allocation information
0040+  0000             _RDRND			= $21					; Random read
0041+  0000             _WRRND			= $22					; Random write
0042+  0000             _FSIZE			= $23					; Get file size
0043+  0000             _SETRND			= $24					; Set random record
0044+  0000             _WRBLK			= $26					; Random block write
0045+  0000             _RDBLK			= $27					; Random block read
0046+  0000             _WRZER			= $28					; Random write with zero fill
0047+  0000             _GDATE			= $2A					; Get date
0048+  0000             _SDATE			= $2B					; Set date
0049+  0000             _GTIME			= $2C					; Get time
0050+  0000             _STIME			= $2D					; Set time
0051+  0000             _VERIFY			= $2E					; Set/reset verify flag
0052+  0000             _RDABS			= $2F					; Absolute sector read
0053+  0000             _WRABS			= $30					; Absolute sector write
0054+  0000             _DPARM			= $31					; Get disk parameters
0055+  0000             _FFIRST			= $40					; Find first entry
0056+  0000             _FNEXT			= $41					; Find next entry
0057+  0000             _FNEW			= $42					; Find = entry
0058+  0000             _OPEN			= $43					; Open file handle
0059+  0000             _CREATE			= $44					; Create file handle
0060+  0000             _CLOSE			= $45					; Close file handle
0061+  0000             _ENSURE			= $46					; Ensure file handle
0062+  0000             _DUP			= $47					; Duplicate file handle
0063+  0000             _READ			= $48					; Read from file handle
0064+  0000             _WRITE			= $49					; Write to file handle
0065+  0000             _SEEK			= $4A					; Move file handle pointer
0066+  0000             _IOCTL			= $4B					; I/O control for devices
0067+  0000             _HTEST			= $4C					; Test file handle
0068+  0000             _DELETE			= $4D					; Delete file or subdirectory
0069+  0000             _RENAME			= $4E					; Rename file or subdirectory
0070+  0000             _MOVE			= $4F					; Move file or subdirectory
0071+  0000             _ATTR			= $50					; Get/set file attributes
0072+  0000             _FTIME			= $51					; Get/set file date and time
0073+  0000             _HDELETE		= $52					; Delete file handle
0074+  0000             _HRENAME		= $53					; Rename file handle
0075+  0000             _HMOVE			= $54					; Move file handle
0076+  0000             _HATTR			= $55					; Get/set file handle attributes
0077+  0000             _HFTIME			= $56					; Get/set file handle date and time
0078+  0000             _GETDTA			= $57					; Get disk transfer address
0079+  0000             _GETVFY			= $58					; Get verify flag setting
0080+  0000             _GETCD			= $59					; Get current directory
0081+  0000             _CHDIR			= $5A					; Change current directory
0082+  0000             _PARSE			= $5B					; Parse pathname
0083+  0000             _PFILE			= $5C					; Parse filename
0084+  0000             _CHKCHR			= $5D					; Check character
0085+  0000             _WPATH			= $5E					; Get whole path string
0086+  0000             _FLUSH			= $5F					; Flush disk buffers
0087+  0000             _FORK			= $60					; Fork a child process
0088+  0000             _JOIN			= $61					; Rejoin parent process
0089+  0000             _TERM			= $62					; Terminate with error code
0090+  0000             _DEFAB			= $63					; Define abort exit routine
0091+  0000             _DEFER			= $64					; Define disk error handler routine
0092+  0000             _ERROR			= $65					; GFet previous error code
0093+  0000             _EXPLAIN		= $66					; Explain error code
0094+  0000             _FORMAT			= $67					; Format a disk
0095+  0000             _RAMD			= $68					; Create or destroy RAM disk
0096+  0000             _BUFFER			= $69					; Allocate sector buffers
0097+  0000             _ASSGIN			= $6A					; Logical drive assignment
0098+  0000             _GENV			= $6B					; Get environment item
0099+  0000             _SENV			= $6C					; Set environment item
0100+  0000             _FENV			= $6D					; Find environment item
0101+  0000             _DSKCHK			= $6E					; Get/set disk check status
0102+  0000             _DOSVER			= $6F					; Get MSX DOS version number
0103+  0000             _REDIR			= $70					; Get/set redirection status
0104+  0000             
0105+  0000             ; Errors
0106+  0000             ERROR: 
0107+  0000             .NCOMP			= $FF					; Incompatible disk
0108+  0000             .WRERR			= $FE					; Write error
0109+  0000             .DISK			= $FD					; Disk error
0110+  0000             .NRDY			= $FC					; Not ready
0111+  0000             .VERFY			= $FB					; Verify error
0112+  0000             .DATA			= $FA					; Data error
0113+  0000             .RNF			= $F9					; Sector not found
0114+  0000             .WPROT			= $F8					; Write protected disk
0115+  0000             .UFORM			= $F7					; Unformatted disk
0116+  0000             .NDOS			= $F6					; Not a DOS disk
0117+  0000             .WDISK			= $F5					; Wrong disk
0118+  0000             .WFILE			= $F4					; Wrong disk for file
0119+  0000             .SEEK			= $F3					; Seek error
0120+  0000             .IFAT			= $F2					; Bad file allocation table
0121+  0000             .NOUPB			= $F1					; --
0122+  0000             .IFORM			= $F0					; Cannot format this drive
0123+  0000             .INTER			= $DF					; Internal error
0124+  0000             .NORAM			= $DE					; Not enough memory
0125+  0000             .IBDOS			= $DC					; Invalid MSX-DOS call
0126+  0000             .IDRV			= $DB					; Invalid drive
0127+  0000             .IFNM			= $DA					; Invalid filename
0128+  0000             .IPATH			= $D9					; Invalid pathname
0129+  0000             .PLONG			= $D8					; Pathname too long
0130+  0000             .NOFIL			= $D7					; File not found
0131+  0000             .NODIR			= $D6					; Directory not found
0132+  0000             .DRFUL			= $D5					; Root directory full
0133+  0000             .DKFUL			= $D4					; Disk full
0134+  0000             .DUPF			= $D3					; Duplicate filename
0135+  0000             .DIRE			= $D2					; Invalid directory move
0136+  0000             .FILRO			= $D1					; Read only file
0137+  0000             .DIRNE			= $D0					; Directory not empty
0138+  0000             .IATTR			= $CF					; Invalid attributes
0139+  0000             .DOT			= $CE					; Invalid . or .. operation
0140+  0000             .SYSX			= $CD					; System file exists
0141+  0000             .DIRX			= $CC					; Directory exists
0142+  0000             .FILEX			= $CB					; File exists
0143+  0000             .FOPEN			= $CA					; File already in use
0144+  0000             .OV64K			= $C9					; Cannot transfer above 64K
0145+  0000             .FILE			= $C8					; File allocation error
0146+  0000             .EOF			= $C7					; End of file
0147+  0000             .ACCV			= $C6					; File access violation
0148+  0000             .IPROC			= $C5					; Invalid process id
0149+  0000             .NHAND			= $C4					; No spare file handles
0150+  0000             .IHAND			= $C3					; Invalid file handle
0151+  0000             .NOPEN			= $C2					; File handle not open
0152+  0000             .IDEV			= $C1					; Invalid device operation
0153+  0000             .IENV			= $C0					; Invalid environment string
0154+  0000             .ELONG			= $BF					; Environment string too long
0155+  0000             .IDATE			= $BE					; Invalid date
0156+  0000             .ITIME			= $BD					; Invalid time
0157+  0000             .RAMDX			= $BC					; RAM disk (drive H ) already exists
0158+  0000             .NRAMD			= $BB					; RAM disk does not exist
0159+  0000             .HDEAD			= $BA					; File handle has been deleted
0160+  0000             .EOL			= $B9					; Internal error. Should never occur
0161+  0000             .ISBFN			= $B8					; Invalid sub-function number
0162+  0000             .STOP			= $9F					; Ctrl-STOP pressed
0163+  0000             .CTRLC			= $9E					; Ctrl-C pressed
0164+  0000             .ABORT			= $9D					; Disk operation aborted
0165+  0000             .OUTERR			= $9C					; Error on standard output
0166+  0000             .INERR			= $9B					; Error on standard input
0167+  0000             .BADCOM			= $8F					; Wrong version of COMMAND
0168+  0000             .BADCM			= $8E					; Unrecognized command
0169+  0000             .BUFUL			= $8D					; Command too long
0170+  0000             .OKCMD			= $8C					; --
0171+  0000             .IPARM			= $8B					; Invalid parameter
0172+  0000             .INP			= $8A					; Too many parameters
0173+  0000             .NOPAR			= $89					; Missing parameter
0174+  0000             .IOPT			= $88					; Invalid option
0175+  0000             .BADNO			= $87					; Invalid number
0176+  0000             .NOHELP			= $86					; File for HELP not found
0177+  0000             .BADVER			= $85					; Wrong version of MSX-DOS
0178+  0000             .NOCAT			= $84					; Cannot concatenate destination file
0179+  0000             .BADEST			= $83					; Cannot create destination file
0180+  0000             .COPY			= $82					; File cannot be copied onto itself
0181+  0000             .OVDEST			= $81					; Cannot overwrite previous destination file
0182+  0000             
0183+  0000             ; Allocate segment parameters
0184+  0000             USER_SEGMENT		= 0					; Register A
0185+  0000             SYSTEM_SEGMENT		= 1					; "        "
0186+  0000             PRIMARY_MAPPER		= 0					; Register B 
0187+  0000             
0188+  0000             ; Open file flags (_OPEN)
0189+  0000             OPEN_NO_WRITE		= 1
0190+  0000             OPEN_NO_READ		= 2
0191+  0000             OPEN_INHERITABLE	= 4
0192+  0000             
0193+  0000             ; Seek file flags
0194+  0000             SEEK_SET			= 0
0195+  0000             SEEK_CUR			= 1
0196+  0000             SEEK_END			= 2
0197+  0000             
0198+  0000             ; File attributes (bit mask)
0199+  0000             FILE_READ_ONLY		= 1					; 
0200+  0000             FILE_HIDDEN			= 2					;
0201+  0000             FILE_SYSTEM			= 4					; 
0202+  0000             FILE_VOLUME_NAME	= 8					; 
0203+  0000             FILE_DIRECTORY		= 16				; 
0204+  0000             FILE_ARCHIVE		= 32				; 
0205+  0000             FILE_RESERVED		= 64				; 
0206+  0000             FILE_DEVICE			= 128				;
0207+  0000             
0208+  0000             ; Disk error handler routine parameters in register C
0209+  0000             ERROR_WRITING		= 1					; Set if writing
0210+  0000             ERROR_NO_IGNORE		= 2					; Set if ignore not recommended
0211+  0000             ERROR_AUTO_ABORT	= 4					; Set if auto-abort suggested
0212+  0000             ERROR_VALID_SECTOR	= 8					; Set if sector number is valid 
0213+  0000             
0214+  0000             
0215+  0000             ; Disk error handler routine return codes
0216+  0000             CALL_SYSTEM_ERROR	= 0					; Call system error routine
0217+  0000             ERROR_ABORT			= 1					; Abort
0218+  0000             ERROR_RETRY			= 2					; Retry
0219+  0000             ERROR_IGNORE		= 3					; Ignore
0220+  0000             
0221+  0000             
0222+  0000             ;  Params _RAMD
0223+  0000             DESTROY_RAMDISK		= 0
0224+  0000             GET_RAMDISK_SIZE	= $FF
0225+  0000             CREATE_RAMDISK		= 1					; CREATE_RAMDISK+n = 1+n
0226+  0000             
0227+  0000             ; Misc
0228+  0000             CR					= 13				; Carridge Return
0229+  0000             LF					= 10				; Line Feed
0230+  0000             LE					= '$'				; Line end
0231+  0000             UPPER_CASE_MASK		= $DF
0232+  0000             
0233+  0000             CMD_LENGTH			= $80
0234+  0000             CMD_LINE			= $82
0235+  0000             
0236+  0000             COM_START_ADDR		= $100
0237+  0000             
0238+  0000             RAMAD0				= $F341				; slotid DOS ram page 0
0239+  0000             RAMAD1				= $F342				; slotid DOS ram page 1
0240+  0000             RAMAD2				= $F343				; slotid DOS ram page 2
0241+  0000             RAMAD3				= $F344				; slotid DOS ram page 3
0242+  0000             SECBUF				= $F34D				; pointer to sectorbuffer, can be used by the diskdriver
0243+  0000             
0021   0000             
0022   0000             
0023   0000             	org		COM_START_ADDR
0024   0100             
0025   0100             ; *** CONSTANTS ***
0026   0100             ALG_BYTE	= 1
0027   0100             ALG_PAGE	= 2
0028   0100             CHGBANK		= $7000
0029   0100             BUFFER1		= $1000
0030   0100             BUFFER2		= $C000
0031   0100             
0032   0100             begin: 
0033   0100             
0034   0100             ; **** MAIN PROGRAM ****
0035   0100             
0036   0100             init: 
0037   0100             	; Actual parameters saved
0038   0100 ED 73 09 0A 	ld		(savesp), sp				; Stack Pointer saved
0039   0104 3A A9 FC    	ld		a, (CSRSW)					; Cursor Saved
0040   0107 32 0C 0A    	ld		(savecursor), a
0041   010A CD 1C 05    	call	cursorOff         			; Turn cursor off (no matter about its state)
0042   010D             
0043   010D 11 B0 06    	ld		de, strTitulo
0044   0110 CD 69 05    	call	print						; Print logo
0045   0113             
0046   0113 CD E3 01    	call	checkDOS					; Dos version checked
0047   0116 CD ED 01    	call	checkSystem					; MSX Type checked
0048   0119 CD 1A 02    	call	checkParams					; Check and Save parameters
0049   011C             
0050   011C 3A 0F 0A    	ld		a, (options)
0051   011F CB 4F       	bit		1, a						; only list chips?
0052   0121 C2 24 06    	jp nz,	showList					; yes, jump
0053   0124             
0054   0124 CD 3B 01    	call	checkFlash     				; Search FLASH ROM
0055   0127             
0056   0127 3A 0F 0A    	ld		a, (options)
0057   012A CB 47       	bit		0, a						; only erasing flash?
0058   012C C2 BF 04    	jp nz,	eraseFlash					; yes, jump to erase it
0059   012F             
0060   012F CD BB 02    	call	checkFile					; Checks if file-argument exists and your size
0061   0132 CD BF 04    	call	eraseFlash					; Erase flash.
0062   0135 CD 29 03    	call	loadFile 					; Load file in flash
0063   0138             
0064   0138 C3 3A 05    	jp		exitok						; No. Exit Program
0065   013B             
0066   013B             
0067   013B             ; *** CHECKING ROUTINES ***
0068   013B             
0069   013B             ; -------------------
0070   013B             ; checkFlash
0071   013B             ; Searches FLASH ROM
0072   013B             ; ------------------
0073   013B             checkFlash: 
0074   013B 11 BC 07    	ld		de, strProcuraFlash
0075   013E CD 69 05    	call	print						; Prints searching message
0076   0141 3E FF       	ld		a, $FF
0077   0143 32 12 0A    	ld		(thisslt), a				; Inits SIGSLOT Routine
0078   0146             .loop: 
0079   0146 F3          	di
0080   0147 CD E2 03    	call	sigslot						; Calls the next slot (first one if first time)
0081   014A FE FF       	cp		$FF							; Is it the last slot?
0082   014C 28 53       	jr z,	.naoachado					; Yes. FLASH was not found
0083   014E             
0084   014E F5          	push	af
0085   014F 26 40       	ld		h, $40						; It is not the last slot. Placed it in page 1
0086   0151 CD 24 00    	call	ENASLT
0087   0154 F1          	pop		af
0088   0155 26 80       	ld		h, $80						; Placed it in page 2 too
0089   0157 CD 24 00    	call	ENASLT
0090   015A             
0091   015A CD B7 01    	call	checkDeviceID				; Searching flash by executing its ID_CHECK command
0092   015D 38 E7       	jr c,	.loop						; Not found in this slot, continue with next one
0093   015F             
0094   015F 3A 12 0A    	ld		a, (thisslt)				; FLASH WAS FOUND
0095   0162 32 13 0A    	ld		(flashslt), a				; Slot saved
0096   0165 F5          	push	af 							; For printing the message of slot / subslot
0097   0166 E6 03       	and		3
0098   0168 C6 30       	add		a, '0'						; ASCII conversion of the Slot
0099   016A 32 0C 08    	ld		(strAchado.slot), a
0100   016D F1          	pop		af
0101   016E 0F          	rrca
0102   016F 0F          	rrca
0103   0170 E6 03       	and		3
0104   0172 C6 30       	add		a, '0'
0105   0174 32 16 08    	ld		(strAchado.subslot), a		; ASCII conversion of the Subslot.
0106   0177             
0107   0177 3A 42 F3    	ld		a, (RAMAD1)
0108   017A 26 40       	ld		h, $40
0109   017C CD 24 00    	call	ENASLT						; Restoring page 1 (Memory again)
0110   017F 3A 43 F3    	ld		a, (RAMAD2)
0111   0182 26 80       	ld		h, $80
0112   0184 CD 24 00    	call	ENASLT						; Restoring page 2 (Memory again)
0113   0187             
0114   0187 11 FE 07    	ld		de, strAchado
0115   018A CD 69 05    	call	print						; Printing message with info about slot / subslot
0116   018D ED 5B 17 0A 	ld		de, (flashManPoint)			; recuperamos string do fabricante
0117   0191 CD 69 05    	call	print
0118   0194 ED 5B 19 0A 	ld		de, (flashProdPoint)		; recuperamos string do produto
0119   0198 CD 69 05    	call	print						; e imprimimos
0120   019B 11 E6 06    	ld		de, strCrLf
0121   019E C3 69 05    	jp		print
0122   01A1             
0123   01A1             .naoachado: 								; FLASH NOT FOUND
0124   01A1 3A 42 F3    	ld		a, (RAMAD1)
0125   01A4 26 40       	ld		h, $40
0126   01A6 CD 24 00    	call	ENASLT						; Memory placed
0127   01A9 3A 43 F3    	ld		a, (RAMAD2)
0128   01AC 26 80       	ld		h, $80
0129   01AE CD 24 00    	call	ENASLT						; Memory placed
0130   01B1 11 E0 07    	ld		de, strNaoAchado
0131   01B4 C3 35 05    	jp		printErro					; Error message, exiting program
0132   01B7             
0133   01B7             ; ------------------------
0134   01B7             ; checkDeviceID
0135   01B7             ; Check Flash Manufacturer and Device ID
0136   01B7             ; Z = 1 if Flash found
0137   01B7             ;
0138   01B7             ; -------------------------
0139   01B7             checkDeviceID: 
0140   01B7 F3          	di
0141   01B8 3E F0       	ld		a, $F0						; Reset
0142   01BA CD 24 04    	call	flashSendCommand
0143   01BD 3E 90       	ld		a, $90						; Software ID Entry
0144   01BF CD 24 04    	call	flashSendCommand
0145   01C2 3A 00 80    	ld		a, ($8000)					; Read Manufacturer ID
0146   01C5 32 14 0A    	ld		(flashIdMan), a
0147   01C8 3A 01 80    	ld		a, ($8001)					; Read Product ID
0148   01CB 32 15 0A    	ld		(flashIdProd), a
0149   01CE CD 6E 06    	call	flashIdent					; Try to identify flash
0150   01D1 3A 16 0A    	ld		a, (flashAlg)
0151   01D4 FE 00       	cp		0
0152   01D6 37          	scf									; Carry = 1 - error
0153   01D7 28 01       	jr z,	.sair
0154   01D9             .ok: 
0155   01D9 AF          	xor		a							; Carry = 0 - OK
0156   01DA             .sair: 
0157   01DA F5          	push	af
0158   01DB 3E F0       	ld		a, $F0						; Reset
0159   01DD CD 24 04    	call	flashSendCommand
0160   01E0 F1          	pop		af
0161   01E1 FB          	ei
0162   01E2 C9          	ret
0163   01E3             
0164   01E3             ; ----------------------
0165   01E3             ; CHECK DOS
0166   01E3             ; check operating system
0167   01E3             ; ----------------------
0168   01E3             checkDOS: 
0169   01E3 0E 6F       	ld		c, _DOSVER
0170   01E5 CD 2D 05    	call	callBdos					; Send DOSVER command to dos
0171   01E8 78          	ld		a, b
0172   01E9 32 0D 0A    	ld		(dos), a					; Save dos version
0173   01EC C9          	ret
0174   01ED             
0175   01ED             ; ----------------
0176   01ED             ; checkSystem
0177   01ED             ; check MSX
0178   01ED             ; ----------------
0179   01ED             checkSystem: 
0180   01ED 3A C1 FC    	ld		a, (EXPTBL)
0181   01F0 21 2D 00    	ld		hl, BASVER
0182   01F3 CD 0C 00    	call	RDSLT						; Check byte $2D (MSX version)
0183   01F6 32 0E 0A    	ld		(system), a
0184   01F9 FE 03       	cp		3							; Turbo R?
0185   01FB D8          	ret	c								; no, return
0186   01FC FD 2A C0 FC 	ld		iy, (EXPTBL - 1)			; is MSX Turbo R
0187   0200 DD 21 83 01 	ld		ix, $183
0188   0204 CD 1C 00    	call	CALSTL
0189   0207 F6 80       	or		$80
0190   0209 32 0B 0A    	ld		(savecpu), a				; save actual CPU mode
0191   020C 3E 80       	ld		a, $80						; and set Z80 for compatibility
0192   020E             
0193   020E             systemSetCPU: 
0194   020E FD 2A C0 FC 	ld		iy, (EXPTBL - 1)
0195   0212 DD 21 80 01 	ld		ix, $180
0196   0216 CD 1C 00    	call	CALSTL
0197   0219 C9          	ret
0198   021A             
0199   021A             ; --------------------
0200   021A             ; checkParams
0201   021A             ; Check line params
0202   021A             ; --------------------
0203   021A             checkParams: 
0204   021A 21 80 00    	ld		hl, CMD_LENGTH
0205   021D 7E          	ld		a, (hl)
0206   021E B7          	or		a							; Parameters?
0207   021F 11 E9 06    	ld		de, strHelp
0208   0222 CA 35 05    	jp z,	printErro					; no parameters. Show Help and exit
0209   0225             
0210   0225 CD 7F 02    	call	checkOptions				; Check parameter options
0211   0228 CD 4D 02    	call	checkFileName				; Check file name
0212   022B             
0213   022B 3A 0D 0A    	ld		a, (dos)
0214   022E FE 02       	cp		2
0215   0230 D2 C2 03    	jp nc,	fillName					; If DOS2 then fill only the name
0216   0233 21 21 0A    	ld		hl, fileNameDOS2			; DOS1. Extract filename
0217   0236 11 61 0A    	ld		de, fileNameDOS1
0218   0239             .loop0: 
0219   0239 7E          	ld		a,(hl)
0220   023A FE 2E       	cp		'.'
0221   023C 28 08       	jr z,	.loop2
0222   023E 12          	ld		(de), a
0223   023F 13          	inc		de
0224   0240             .loop1: 
0225   0240 23          	inc		hl
0226   0241 10 F6       	djnz	.loop0
0227   0243 C3 C2 03    	jp		fillName
0228   0246             .loop2: 
0229   0246 11 69 0A    	ld		de, filenDOS1Ext
0230   0249 06 04       	ld		b, 4
0231   024B 18 F3       	jr		.loop1
0232   024D             
0233   024D             ; -------------------
0234   024D             ; checkFileName
0235   024D             ; Extract the name of
0236   024D             ; the parameters in
0237   024D             ; DOS2 format
0238   024D             ; ------------------
0239   024D             checkFileName: 
0240   024D 3A 80 00    	ld		a, (CMD_LENGTH)
0241   0250 FE 01       	cp		1
0242   0252 47          	ld		b, a
0243   0253 28 01       	jr z,	.p1
0244   0255 05          	dec		b
0245   0256             .p1: 
0246   0256 21 82 00    	ld		hl, CMD_LINE
0247   0259 11 21 0A    	ld		de, fileNameDOS2
0248   025C 0E 00       	ld		c, 0
0249   025E             .loop0: 
0250   025E 7E          	ld		a, (hl)
0251   025F B7          	or		a
0252   0260 28 11       	jr z,	.p2
0253   0262 FE 2F       	cp		'/'
0254   0264 CA 74 02    	jp z,	.p3
0255   0267 FE 20       	cp		' '
0256   0269 CA 73 02    	jp z,	.p2
0257   026C FE 0D       	cp		13
0258   026E 28 03       	jr z,	.p2
0259   0270 12          	ld		(de),a
0260   0271 13          	inc		de
0261   0272 0C          	inc		c
0262   0273             .p2: 
0263   0273 2B          	dec		hl
0264   0274             .p3: 
0265   0274 23          	inc		hl
0266   0275 23          	inc		hl
0267   0276 10 E6       	djnz	.loop0
0268   0278 41          	ld		b, c
0269   0279 79          	ld		a, c
0270   027A B7          	or		a
0271   027B C0          	ret	nz
0272   027C 06 01       	ld		b, 1
0273   027E C9          	ret
0274   027F             
0275   027F             ; --------------------------------------
0276   027F             ; checkOptions
0277   027F             ; OPTIONS :
0278   027F             ;			0 - erase flash only	/e
0279   027F             ;			1 - show list of chips	/l
0280   027F             ;
0281   027F             ; ---------------------------------------
0282   027F             checkOptions: 
0283   027F C5          	push	bc
0284   0280 AF          	xor		a
0285   0281 32 0F 0A    	ld		(options), a
0286   0284 3A 80 00    	ld		a, (CMD_LENGTH)
0287   0287 47          	ld		b, a
0288   0288 21 82 00    	ld		hl, CMD_LINE
0289   028B             .loop0: 
0290   028B 7E          	ld		a, (hl)
0291   028C FE 2F       	cp		'/'
0292   028E CC 95 02    	call	z, .ch1
0293   0291             .p1: 
0294   0291 23          	inc		hl
0295   0292 10 F7       	djnz	.loop0
0296   0294 C1          	pop		bc
0297   0295             
0298   0295             .ch1: 
0299   0295 23          	inc		hl
0300   0296 7E          	ld		a, (hl)
0301   0297 F6 20       	or		000100000b
0302   0299 11 E9 06    	ld		de, strHelp
0303   029C FE 3F       	cp		'?'
0304   029E CA 35 05    	jp z,	printErro
0305   02A1 FE 68       	cp		'h'
0306   02A3 CA 35 05    	jp z,	printErro
0307   02A6             
0308   02A6 0E 01       	ld		c, 1
0309   02A8 FE 65       	cp		'e'
0310   02AA 28 07       	jr z,	.achado
0311   02AC CB 21       	sla		c
0312   02AE FE 6C       	cp		'l'
0313   02B0 28 01       	jr z,	.achado
0314   02B2 C9          	ret
0315   02B3             .achado: 
0316   02B3 3A 0F 0A    	ld		a, (options)
0317   02B6 B1          	or		c
0318   02B7 32 0F 0A    	ld		(options), a
0319   02BA C9          	ret
0320   02BB             
0321   02BB             ; ---------------------
0322   02BB             ; CHECK FILE
0323   02BB             ; CHECK IF FILE EXIST
0324   02BB             ; ---------------------
0325   02BB             checkFile: 
0326   02BB 11 83 08    	ld		de, strOpenFile
0327   02BE CD 69 05    	call	print						; Open text
0328   02C1 3A 0D 0A    	ld		a, (dos)
0329   02C4 FE 02       	cp		2
0330   02C6 D2 D8 02    	jp nc,	.dos2						; DOS2 mode
0331   02C9             
0332   02C9 CD 6E 05    	call	makeFCB						; DOS1. Make FCB and Open command.
0333   02CC 21 61 0A    	ld		hl, fileNameDOS1
0334   02CF CD 7C 05    	call	buildFCB
0335   02D2 CD 85 05    	call	open						; Open. If file doesn't exist then error and exit.
0336   02D5 C3 0F 03    	jp		.p1
0337   02D8             
0338   02D8             .dos2: 									; DOS2 Open
0339   02D8 11 21 0A    	ld		de, fileNameDOS2
0340   02DB AF          	xor		a
0341   02DC 06 00       	ld		b, 0
0342   02DE 0E 43       	ld		c, _OPEN					; Open file DOS2
0343   02E0 CD 2D 05    	call	callBdos
0344   02E3 11 3B 08    	ld		de, strErroAbrirArq
0345   02E6 C2 35 05    	jp nz,	printErro					; if Z = 0 then file not found. Error and Exit
0346   02E9 78          	ld		a, b
0347   02EA 32 20 0A    	ld		(fileHandle), a				; Save FILE HANDLE
0348   02ED C5          	push	bc							; For check size in DOS 2, use SEEK Command.
0349   02EE 3E 02       	ld		a, SEEK_END
0350   02F0 11 00 00    	ld		de, 0
0351   02F3 21 00 00    	ld		hl, 0
0352   02F6 0E 4A       	ld		c, _SEEK					; Seek
0353   02F8 CD 2D 05    	call	callBdos
0354   02FB 22 80 0A    	ld		(sizefile), hl
0355   02FE ED 53 82 0A 	ld		(sizefile+2), de
0356   0302 C1          	pop		bc
0357   0303 AF          	xor		a							; And Now Return Seek to POS 0 (SEEK_SET)
0358   0304 11 00 00    	ld		de, 0
0359   0307 21 00 00    	ld		hl, 0
0360   030A 0E 4A       	ld		c, _SEEK
0361   030C CD 2D 05    	call	callBdos
0362   030F             .p1: 
0363   030F 11 60 08    	ld		de, strTamanhoErrado		; Test filesize. 128K = 00 00 02
0364   0312 3A 80 0A    	ld		a, (sizefile)
0365   0315 B7          	or		a
0366   0316 C2 35 05    	jp nz,	printErro
0367   0319 3A 81 0A    	ld		a, (sizefile+1)
0368   031C B7          	or		a
0369   031D C2 35 05    	jp nz,	printErro
0370   0320 3A 82 0A    	ld		a, (sizefile+2)
0371   0323 FE 02       	cp		2
0372   0325 C2 35 05    	jp nz,	printErro
0373   0328 C9          	ret
0374   0329             
0375   0329             ; *** PROGRAM ROUTINES ***
0376   0329             
0377   0329             ; ----------------------------
0378   0329             ; LOADFILE
0379   0329             ; Load File into Flash
0380   0329             ; Load ALL FILE into Flash ROM
0381   0329             ; ----------------------------
0382   0329             loadFile: 
0383   0329 11 B7 08    	ld		de, strWriting
0384   032C CD 69 05    	call	print						; Show Write Text
0385   032F 06 08       	ld		b, 8						; 8 blocks of 16K = 128K
0386   0331             .loop: 
0387   0331 C5          	push	bc
0388   0332 CD 62 03    	call	fillBuffers					; fill buffers with $FF
0389   0335 CD 7D 03    	call	load16K						; and load one 16 K page to buffers
0390   0338 F3          	di
0391   0339 CD 46 04    	call	writeFlash					; now write this 16 K to FLASH
0392   033C FB          	ei
0393   033D 11 C5 08    	ld		de, strErroAoGravarFlash
0394   0340 C2 35 05    	jp nz,	printErro					; oops! Error writing bytes. Show Error and exit.
0395   0343             
0396   0343 11 B5 08    	ld		de, strDot
0397   0346 CD 69 05    	call	print						; show '*' for 16 K page loaded
0398   0349 C1          	pop		bc
0399   034A 3A 11 0A    	ld		a, (actualpage)
0400   034D 3C          	inc		a
0401   034E 32 11 0A    	ld		(actualpage), a				; and inc page to next loop
0402   0351 10 DE       	djnz	.loop						; next loop
0403   0353             
0404   0353 CD CF 05    	call	closeFile					; end for load. close File.
0405   0356 11 E6 06    	ld		de, strCrLf
0406   0359 CD 69 05    	call	print
0407   035C 11 E2 08    	ld		de, strUpdateCompleto		; and print Success Text.
0408   035F C3 69 05    	jp		print
0409   0362             
0410   0362             
0411   0362             ; --------------------
0412   0362             ; FILLBUFFERs
0413   0362             ; Fill buffers with $FF
0414   0362             ; ---------------------
0415   0362             fillBuffers: 
0416   0362 21 00 10    	ld		hl, BUFFER1
0417   0365 11 01 10    	ld		de, BUFFER1+1
0418   0368 01 FF 2F    	ld		bc, $2FFF
0419   036B 36 FF       	ld		(hl), $FF
0420   036D ED B0       	ldir								; fill
0421   036F 21 00 C0    	ld		hl, BUFFER2
0422   0372 11 01 C0    	ld		de, BUFFER2+1
0423   0375 01 FF 0F    	ld		bc, $0FFF
0424   0378 36 FF       	ld		(hl), $FF
0425   037A ED B0       	ldir								; fill
0426   037C C9          	ret
0427   037D             
0428   037D             ; ------------------
0429   037D             ; LOAD16K
0430   037D             ; Load 16K to buffers
0431   037D             ; from file open
0432   037D             ; ------------------
0433   037D             load16K: 
0434   037D             	; this code load 16 KB from file
0435   037D             	; to buffers
0436   037D FB          	ei
0437   037E 11 00 10    	ld		de, BUFFER1					; buffer pointer
0438   0381 21 00 30    	ld		hl, $3000					; length
0439   0384 3A 0D 0A    	ld		a, (dos)
0440   0387 FE 02       	cp		2
0441   0389 30 0D       	jr nc,	.dos2_1						; if DOS 2 make <> load
0442   038B E5          	push	hl							; DOS 1 LOAD.
0443   038C CD C2 05    	call	setDTA						; set DTA
0444   038F E1          	pop		hl
0445   0390 CD E7 05    	call	readMax						; and read 8 KB or max if file < 8K or file size
0446   0393 CD C7 05    	call	readFile					; is not mult. of 16. And READ.
0447   0396 18 09       	jr		.next
0448   0398             .dos2_1: 								; DOS 2 LOAD
0449   0398 3A 20 0A    	ld		a, (fileHandle)
0450   039B 47          	ld		b, a
0451   039C 0E 48       	ld		c, _READ					; DOS 2 COMMAND Read
0452   039E CD 25 05    	call	callBdosCE
0453   03A1             .next: 
0454   03A1 11 00 C0    	ld		de, BUFFER2					; buffer pointer
0455   03A4 21 00 10    	ld		hl, $1000					; length
0456   03A7 3A 0D 0A    	ld		a, (dos)
0457   03AA FE 02       	cp		2
0458   03AC 30 0B       	jr nc,	.dos2_2						; if DOS 2 make <> load
0459   03AE E5          	push	hl							; DOS 1 LOAD.
0460   03AF CD C2 05    	call	setDTA						; set DTA
0461   03B2 E1          	pop		hl
0462   03B3 CD E7 05    	call	readMax						; and read 8 KB or max if file < 8K or file size
0463   03B6 C3 C7 05    	jp		readFile					; is not mult. of 16. And READ.
0464   03B9             .dos2_2: 								; DOS 2 LOAD
0465   03B9 3A 20 0A    	ld		a, (fileHandle)
0466   03BC 47          	ld		b, a
0467   03BD 0E 48       	ld		c, _READ					; DOS 2 COMMAND Read
0468   03BF C3 25 05    	jp		callBdosCE
0469   03C2             
0470   03C2             ; -----------------
0471   03C2             ; FILLNAME
0472   03C2             ; Search params for
0473   03C2             ; extract fileName
0474   03C2             ; -----------------
0475   03C2             fillName: 
0476   03C2 21 60 0A    	ld		hl, fileNameDOS2 + 63
0477   03C5 06 40       	ld		b, 64						; max params. End to init loop
0478   03C7             .loop: 
0479   03C7 7E          	ld		a,(hl)
0480   03C8 B7          	or		a
0481   03C9 28 08       	jr z,	.p1							; 0 dec
0482   03CB FE 3A       	cp		':'							; end
0483   03CD 28 07       	jr z,	.p2
0484   03CF FE 5C       	cp		'\\'						; params
0485   03D1 28 03       	jr z,	.p2
0486   03D3             .p1: 
0487   03D3 2B          	dec		hl
0488   03D4 10 F1       	djnz	.loop
0489   03D6             .p2: 
0490   03D6 23          	inc		hl
0491   03D7 11 91 08    	ld		de, strOpenFile.filename		; loop for fill fileNameShow
0492   03DA             .loop2: 
0493   03DA 7E          	ld		a, (hl)
0494   03DB B7          	or		a
0495   03DC C8          	ret z
0496   03DD 12          	ld		(de),a
0497   03DE 23          	inc		hl
0498   03DF 13          	inc		de
0499   03E0 18 F8       	jr		.loop2
0500   03E2             
0501   03E2             ; -------------------------------------------------------
0502   03E2             ; SIGSLOT
0503   03E2             ; Returns in A the next slot every time it is called.
0504   03E2             ; For initializing purposes, thisslt has to be #FF.
0505   03E2             ; If no more slots, it returns A=#FF.
0506   03E2             ; this code is programmed by Nestor Soriano aka Konamiman
0507   03E2             ; --------------------------------------------------------
0508   03E2             sigslot: 
0509   03E2 3A 12 0A    	ld		a, (thisslt)				; Returns the next slot, starting by
0510   03E5 FE FF       	cp		$FF							; slot 0. Returns #FF when there are not more slots
0511   03E7 20 09       	jr nz,	.p1							; Modifies AF, BC, HL.
0512   03E9 3A C1 FC    	ld		a, (EXPTBL)
0513   03EC E6 80       	and		%10000000
0514   03EE 32 12 0A    	ld		(thisslt), a
0515   03F1 C9          	ret
0516   03F2             .p1: 
0517   03F2 3A 12 0A    	ld		a, (thisslt)
0518   03F5 FE 8F       	cp		%10001111
0519   03F7 28 28       	jr z,	.nomaslt
0520   03F9 FE 03       	cp		%00000011
0521   03FB 28 24       	jr z,	.nomaslt
0522   03FD CB 7F       	bit		7, a
0523   03FF 20 12       	jr nz,	.sltexp
0524   0401             .p2: 
0525   0401 E6 03       	and		%00000011
0526   0403 3C          	inc		a
0527   0404 4F          	ld		c, a
0528   0405 06 00       	ld		b, 0
0529   0407 21 C1 FC    	ld		hl, EXPTBL
0530   040A 09          	add		hl, bc
0531   040B 7E          	ld		a, (hl)
0532   040C E6 80       	and		%10000000
0533   040E B1          	or		c
0534   040F 32 12 0A    	ld		(thisslt), a
0535   0412 C9          	ret
0536   0413             .sltexp: 
0537   0413 4F          	ld		c, a
0538   0414 E6 0C       	and		%00001100
0539   0416 FE 0C       	cp		%00001100
0540   0418 79          	ld		a, c
0541   0419 28 E6       	jr z,	.p2
0542   041B C6 04       	add		a, %00000100
0543   041D 32 12 0A    	ld		(thisslt), a
0544   0420 C9          	ret
0545   0421             .nomaslt: 
0546   0421 3E FF       	ld		a, $FF
0547   0423 C9          	ret
0548   0424             
0549   0424             ; *** FLASH ROUTINES ***
0550   0424             
0551   0424             ; ----------------------
0552   0424             ; flashSendCommand
0553   0424             ; send command in A to 
0554   0424             ; flash mapped in page 2
0555   0424             ; Preserve flags
0556   0424             ; ----------------------
0557   0424             flashSendCommand: 
0558   0424 E5          	push	hl
0559   0425 F5          	push	af
0560   0426 3E 01       	ld		a, $01
0561   0428 32 00 70    	ld		(CHGBANK), a				; Selects bank 1
0562   042B 21 55 95    	ld		hl, $9555					; Write $AA to flash absolute address $5555
0563   042E 36 AA       	ld		(hl), $AA
0564   0430 3E 00       	ld		a, $00
0565   0432 32 00 70    	ld		(CHGBANK), a				; Selects bank 0
0566   0435 21 AA AA    	ld		hl, $AAAA					; Write $55 to flash absolute address $2AAA
0567   0438 36 55       	ld		(hl), $55
0568   043A 3E 01       	ld		a, $01
0569   043C 32 00 70    	ld		(CHGBANK), a				; Selects bank 1
0570   043F 21 55 95    	ld		hl, $9555					; Write command to flash absolute address $5555
0571   0442 F1          	pop		af
0572   0443 77          	ld		(hl), a
0573   0444 E1          	pop		hl
0574   0445 C9          	ret
0575   0446             
0576   0446             ; ----------------------
0577   0446             ; WRITEFLASH
0578   0446             ; Write 16 KB into Flash
0579   0446             ; NZ = Error
0580   0446             ; ----------------------
0581   0446             writeFlash: 
0582   0446 3A 13 0A    	ld		a, (flashslt)
0583   0449 26 40       	ld		h, $40
0584   044B CD 24 00    	call	ENASLT						; flash to frame 1
0585   044E 3A 13 0A    	ld		a, (flashslt)
0586   0451 26 80       	ld		h, $80
0587   0453 CD 24 00    	call	ENASLT						; flash to frame 2
0588   0456 21 00 10    	ld		hl, BUFFER1					; buffer pointer
0589   0459 11 00 80    	ld		de, $8000					; flash pointer
0590   045C 01 00 30    	ld		bc, $3000					; 12K
0591   045F             .loop1: 
0592   045F 3E A0       	ld		a, $A0						; Flash Write Byte Command
0593   0461 CD 24 04    	call	flashSendCommand
0594   0464 3A 11 0A    	ld		a, (actualpage)
0595   0467 32 00 70    	ld		(CHGBANK), a				; select 16K bank in frame 2
0596   046A CD A8 04    	call	writeByte					; program byte
0597   046D 20 26       	jr nz,	.exit						; ERROR.
0598   046F 23          	inc		hl							; Ok. Next byte.
0599   0470 13          	inc		de
0600   0471 0B          	dec		bc
0601   0472 78          	ld		a, b
0602   0473 B1          	or		c
0603   0474 C2 5F 04    	jp nz,	.loop1						; All programmed? Return for making next block.
0604   0477             
0605   0477 21 00 C0    	ld		hl, BUFFER2					; buffer pointer
0606   047A 01 00 10    	ld		bc, $1000					; 4K
0607   047D             .loop2: 
0608   047D 3E A0       	ld		a, $A0						; Flash Write Byte Command
0609   047F CD 24 04    	call	flashSendCommand
0610   0482 3A 11 0A    	ld		a, (actualpage)
0611   0485 32 00 70    	ld		(CHGBANK), a				; select 16K bank in frame 2
0612   0488 CD A8 04    	call	writeByte					; program byte
0613   048B 20 08       	jr nz,	.exit						; ERROR.
0614   048D 23          	inc		hl							; Ok. Next byte.
0615   048E 13          	inc		de
0616   048F 0B          	dec		bc
0617   0490 78          	ld		a, b
0618   0491 B1          	or		c
0619   0492 C2 7D 04    	jp nz,	.loop2						; All programmed? Return for making next block.
0620   0495             .exit: 
0621   0495 F5          	push	af
0622   0496 3A 42 F3    	ld		a, (RAMAD1)
0623   0499 26 40       	ld		h, $40
0624   049B CD 24 00    	call	ENASLT						; Mem to PAGE 1
0625   049E 3A 43 F3    	ld		a, (RAMAD2)
0626   04A1 26 80       	ld		h, $80
0627   04A3 CD 24 00    	call	ENASLT						; Mem to PAGE 2
0628   04A6 F1          	pop		af
0629   04A7 C9          	ret
0630   04A8             
0631   04A8             ; program byte and check 30 times
0632   04A8             writeByte: 
0633   04A8 E5          	push	hl
0634   04A9 D5          	push	de
0635   04AA C5          	push	bc
0636   04AB 0E 1E       	ld		c, 30
0637   04AD             .loop2: 									; write byte loop
0638   04AD 7E          	ld		a, (hl)
0639   04AE 12          	ld		(de), a
0640   04AF             .loop3: 
0641   04AF 00          	nop									; little delay
0642   04B0 00          	nop
0643   04B1 0D          	dec		c
0644   04B2 1A          	ld		a, (de)
0645   04B3 AE          	xor		(hl)
0646   04B4 28 05       	jr z,	.fim						; ok programmed
0647   04B6 79          	ld		a, c
0648   04B7 B7          	or		a
0649   04B8 20 F5       	jr nz,	.loop3
0650   04BA 3C          	inc		a							; oops! Error
0651   04BB             .fim: 
0652   04BB C1          	pop		bc
0653   04BC D1          	pop		de
0654   04BD E1          	pop		hl
0655   04BE C9          	ret
0656   04BF             
0657   04BF             ; -----------------------
0658   04BF             ; ERASEFLASH
0659   04BF             ; Sector Erase command
0660   04BF             ; or CHIP Erase Command
0661   04BF             ; -----------------------
0662   04BF             eraseFlash: 
0663   04BF 11 A4 08    	ld		de, strEraseFlash
0664   04C2 CD 69 05    	call	print						; Erase Text Show.
0665   04C5 3A 13 0A    	ld		a, (flashslt)
0666   04C8 26 40       	ld		h, $40
0667   04CA CD 24 00    	call	ENASLT						; set flash in page 1
0668   04CD 3A 13 0A    	ld		a, (flashslt)
0669   04D0 26 80       	ld		h, $80
0670   04D2 CD 24 00    	call	ENASLT						; and page 2
0671   04D5 F3          	di
0672   04D6 3E 80       	ld		a, $80						; Erase all command
0673   04D8 CD 24 04    	call	flashSendCommand
0674   04DB 3E 10       	ld		a, $10
0675   04DD CD 24 04    	call	flashSendCommand
0676   04E0 21 00 80    	ld		hl, $8000
0677   04E3 7E          	ld		a, (hl)
0678   04E4 32 1B 0A    	ld		(togglebit), a
0679   04E7             .loop: 									; test finish by Toggle Bit
0680   04E7 3A 1B 0A    	ld		a, (togglebit)
0681   04EA BE          	cp		(hl)
0682   04EB 7E          	ld		a, (hl)
0683   04EC 32 1B 0A    	ld		(togglebit), a
0684   04EF 20 F6       	jr nz,	.loop
0685   04F1 3E F0       	ld		a, $F0						; end command. Reset Command.
0686   04F3 CD 24 04    	call	flashSendCommand
0687   04F6 FB          	ei
0688   04F7 3A 42 F3    	ld		a, (RAMAD1)
0689   04FA 26 40       	ld		h, $40
0690   04FC CD 24 00    	call	ENASLT						; set mem to page 1
0691   04FF 3A 43 F3    	ld		a, (RAMAD2)
0692   0502 26 80       	ld		h, $80
0693   0504 CD 24 00    	call	ENASLT						; set mem to page 2
0694   0507 11 1F 08    	ld		de, strOk
0695   050A CD 69 05    	call	print
0696   050D 3A 0F 0A    	ld		a, (options)
0697   0510 CB 47       	bit		0, a						; check if /e command.
0698   0512 C8          	ret	z								; No. Return to Main program
0699   0513 C3 3A 05    	jp		exitok						; Yes. Exit.
0700   0516             
0701   0516             
0702   0516             ; *** GENERIC SYSTEM ROUTINES ***
0703   0516             
0704   0516             ; -------------
0705   0516             ; CURSOR ON OFF
0706   0516             ; -------------
0707   0516             cursorOn: 
0708   0516 3E 01       	ld		a, 1
0709   0518             
0710   0518             cursorSet: 
0711   0518 32 A9 FC    	ld		(CSRSW), a
0712   051B C9          	ret
0713   051C             
0714   051C             cursorOff: 
0715   051C AF          	xor		a
0716   051D 18 F9       	jr		cursorSet
0717   051F             
0718   051F             
0719   051F             ; ----------------
0720   051F             ; cmpHLcomDE
0721   051F             ; Compares HL and DE
0722   051F             ; BIOS RST 020H clone
0723   051F             ; -----------------
0724   051F             cmpHLcomDE: 
0725   051F 7C          	ld		a, h
0726   0520 92          	sub		d
0727   0521 C0          	ret		nz
0728   0522 7D          	ld		a, l
0729   0523 93          	sub		e
0730   0524 C9          	ret
0731   0525             
0732   0525             ; ---------------
0733   0525             ; BDOSCE
0734   0525             ; bdos with error
0735   0525             ; Call to BDOS and
0736   0525             ; check error
0737   0525             ; ----------------
0738   0525             callBdosCE: 
0739   0525 CD 05 00    	call	BDOS
0740   0528 B7          	or		a
0741   0529 C2 32 05    	jp nz,	error
0742   052C C9          	ret
0743   052D             
0744   052D             ; -----------------
0745   052D             ; BDOS
0746   052D             ; bdos without error
0747   052D             ; ------------------
0748   052D             callBdos: 
0749   052D CD 05 00    	call	BDOS
0750   0530 B7          	or		a
0751   0531 C9          	ret
0752   0532             
0753   0532             ; -----------------------------------------------
0754   0532             ; ERROR
0755   0532             ; print error
0756   0532             ; call printErro and set DE pointer to error text
0757   0532             ; -----------------------------------------------
0758   0532             error: 
0759   0532 11 26 08    	ld		de, strErro
0760   0535             printErro: 
0761   0535 0E 09       	ld		c, _STROUT
0762   0537 CD 2D 05    	call	callBdos
0763   053A             
0764   053A             ; ---------------
0765   053A             ; EXITOK
0766   053A             ; Exit OK
0767   053A             ; ---------------
0768   053A             exitok: 
0769   053A CD CF 05    	call	closeFile					; close file (open or not)
0770   053D 3A 42 F3    	ld		a, (RAMAD1)
0771   0540 26 40       	ld		h, $40
0772   0542 CD 24 00    	call	ENASLT						; set mem to page 1
0773   0545 3A 43 F3    	ld		a, (RAMAD2)
0774   0548 26 80       	ld		h, $80
0775   054A CD 24 00    	call	ENASLT						; set mem to page 2
0776   054D 3A 0E 0A    	ld		a, (system)
0777   0550 FE 03       	cp		3							; Turbo R?
0778   0552 38 06       	jr c,	exit						; No. Go To Exit
0779   0554 3A 0B 0A    	ld		a, (savecpu)				; Yes. Restore CPU Mode
0780   0557 CD 0E 02    	call	systemSetCPU
0781   055A             
0782   055A             ; ---------------
0783   055A             ; EXIT
0784   055A             ; program exit
0785   055A             ; ---------------
0786   055A             exit: 
0787   055A 3A 0C 0A    	ld		a,(savecursor)				; Restore Cursor Value
0788   055D CD 18 05    	call	cursorSet
0789   0560 ED 7B 09 0A 	ld		sp, (savesp)				; And Restore SP
0790   0564 0E 00       	ld		c, _TERM0					; Program Terminate BDOS Command.
0791   0566 C3 2D 05    	jp		callBdos					; Go and Exit. WOW!
0792   0569             
0793   0569             ; *** BDOS ROUTINES ***
0794   0569             
0795   0569             ; -------------------
0796   0569             ; PRINT
0797   0569             ; DE : Pointer to Text
0798   0569             ; --------------------
0799   0569             print: 
0800   0569 0E 09       	ld		c, _STROUT
0801   056B C3 2D 05    	jp		callBdos
0802   056E             
0803   056E             ; ----------------
0804   056E             ; makeFCB
0805   056E             ; Prepare NEW FCB
0806   056E             ; ---------------
0807   056E             makeFCB: 
0808   056E 21 70 0A    	ld		hl, FCB
0809   0571 11 71 0A    	ld		de, FCB+1
0810   0574 36 00       	ld		(hl), 0
0811   0576 01 25 00    	ld		bc, 37
0812   0579 ED B0       	ldir
0813   057B C9          	ret
0814   057C             
0815   057C             ; -------------
0816   057C             ; buildFCB
0817   057C             ; HL = Pointer to namefile string
0818   057C             ; ----------------
0819   057C             buildFCB: 
0820   057C 11 71 0A    	ld		de, fileName
0821   057F 01 0B 00    	ld		bc, 11
0822   0582 ED B0       	ldir
0823   0584 C9          	ret
0824   0585             
0825   0585             ; ---------------
0826   0585             ; OPEN FCB FILE
0827   0585             ; ---------------
0828   0585             open: 
0829   0585 11 70 0A    	ld		de, FCB
0830   0588 0E 0F       	ld		c, _FOPEN
0831   058A CD 2D 05    	call	callBdos
0832   058D 11 3B 08    	ld		de, strErroAbrirArq
0833   0590 C2 35 05    	jp nz,	printErro
0834   0593 DD 21 70 0A 	ld		ix, FCB
0835   0597 3E 01       	ld		a, 1
0836   0599 DD 77 0E    	ld		(ix+14), a
0837   059C AF          	xor		a
0838   059D DD 77 0F    	ld		(ix+15), a
0839   05A0 DD 36 21 00 	ld		(ix+33), 0
0840   05A4 DD 36 22 00 	ld		(ix+34), 0
0841   05A8 DD 36 23 00 	ld		(ix+35), 0
0842   05AC DD 36 24 00 	ld		(ix+36), 0
0843   05B0 C9          	ret
0844   05B1             
0845   05B1             ; --------------
0846   05B1             ; SEEK
0847   05B1             ; DEHL = Pointer
0848   05B1             ; --------------
0849   05B1             seek: 
0850   05B1 DD 21 70 0A 	ld		ix, FCB
0851   05B5 DD 75 21    	ld		(ix+33), l
0852   05B8 DD 74 22    	ld		(ix+34), h
0853   05BB DD 73 23    	ld		(ix+35), e
0854   05BE DD 72 24    	ld		(ix+36), d
0855   05C1 C9          	ret
0856   05C2             
0857   05C2             ; ------------
0858   05C2             ; setDTA
0859   05C2             ; DE = Buffer
0860   05C2             ; ------------
0861   05C2             setDTA: 
0862   05C2 0E 1A       	ld		c, _SETDTA
0863   05C4 C3 2D 05    	jp		callBdos
0864   05C7             
0865   05C7             ; -------------------------------------------------------
0866   05C7             ; READ
0867   05C7             ; HL Bytes to read from opened FCB, with the pointer ready
0868   05C7             ; -------------------------------------------------------
0869   05C7             readFile: 
0870   05C7 11 70 0A    	ld		de, FCB
0871   05CA 0E 27       	ld		c, _RDBLK
0872   05CC C3 25 05    	jp		callBdosCE
0873   05CF             
0874   05CF             ; ----------------
0875   05CF             ; closeFile
0876   05CF             ; close FCB FILE
0877   05CF             ; close File. Check DOS variable for DOS2 and DOS1 close
0878   05CF             ; ----------------
0879   05CF             closeFile: 
0880   05CF 3A 0D 0A    	ld		a, (dos)
0881   05D2 FE 02       	cp		2
0882   05D4 30 08       	jr nc,	.dos2
0883   05D6 11 70 0A    	ld		de, FCB
0884   05D9 0E 10       	ld		c, _FCLOSE
0885   05DB C3 2D 05    	jp		callBdos
0886   05DE             .dos2: 
0887   05DE 3A 20 0A    	ld		a, (fileHandle)
0888   05E1 47          	ld		b, a
0889   05E2 0E 45       	ld		c, _CLOSE
0890   05E4 C3 2D 05    	jp		callBdos
0891   05E7             
0892   05E7             ; -------------------------
0893   05E7             ; READ MAX
0894   05E7             ; HL : Size to read
0895   05E7             ; Returns HL max size
0896   05E7              ; this code is for DOS1 Compatibility
0897   05E7              ; In DOS2 if HL parameter (Read Size) > Size File or Bytes to read
0898   05E7              ; Do not Return ERROR
0899   05E7              ; But DOS1 RETURN ERROR
0900   05E7              ; The Load16K Code USES HL = 16384 bytes ALWAYS.
0901   05E7             ; -------------------------
0902   05E7             readMax: 
0903   05E7 F5          	push	af
0904   05E8 D5          	push	de
0905   05E9 E5          	push	hl
0906   05EA AF          	xor		a
0907   05EB 2A 82 0A    	ld		hl, (sizefile+2)
0908   05EE ED 5B 93 0A 	ld		de, (sizeread+2)
0909   05F2 ED 52       	sbc		hl, de
0910   05F4 22 1E 0A    	ld		(sizefiletmp+2), hl
0911   05F7 2A 80 0A    	ld		hl, (sizefile)
0912   05FA ED 5B 91 0A 	ld		de, (sizeread)
0913   05FE ED 52       	sbc		hl, de
0914   0600 22 1C 0A    	ld		(sizefiletmp), hl
0915   0603 E1          	pop		hl
0916   0604 E5          	push	hl
0917   0605 ED 5B 1C 0A 	ld		de, (sizefiletmp)
0918   0609 CD 1F 05    	call	cmpHLcomDE
0919   060C 30 04       	jr nc,	.readmax0
0920   060E E1          	pop		hl
0921   060F             .readmaxend: 
0922   060F D1          	pop		de
0923   0610 F1          	pop		af
0924   0611 C9          	ret
0925   0612             .readmax0: 
0926   0612 ED 5B 1E 0A 	ld		de, (sizefiletmp+2)
0927   0616 21 00 00    	ld		hl, 0
0928   0619 CD 1F 05    	call	cmpHLcomDE
0929   061C E1          	pop		hl
0930   061D 20 F0       	jr nz,	.readmaxend
0931   061F             .readmax1: 
0932   061F 2A 1C 0A    	ld		hl, (sizefiletmp)
0933   0622 18 EB       	jr		.readmaxend
0934   0624             
0935   0624             ; ----------------------
0936   0624             ; ShowList
0937   0624             ; Exibe a lista de flashs
0938   0624             ; suportadas
0939   0624             ; ----------------------
0940   0624             showList: 
0941   0624 11 04 09    	ld		de, strListaCab
0942   0627 CD 69 05    	call	print
0943   062A 21 47 09    	ld		hl, tblFlash				; HL points to table start
0944   062D             .loop: 
0945   062D 7E          	ld		a, (hl)
0946   062E FE 00       	cp		0							; no more entries?
0947   0630 CA 5A 05    	jp z,	exit
0948   0633 32 14 0A    	ld		(flashIdMan), a				; save manufacturer ID
0949   0636 23          	inc		hl
0950   0637 7E          	ld		a, (hl)						; get product ID
0951   0638 32 15 0A    	ld		(flashIdProd), a			; save it
0952   063B 23          	inc		hl
0953   063C 5E 23 56 2B 	ld		de, (hl)					; Get string pointer of manufacturer
0954   0640 ED 53 17 0A 	ld		(flashManPoint), de			; save it
0955   0644 23          	inc		hl
0956   0645 23          	inc		hl
0957   0646 5E 23 56 2B 	ld		de, (hl)					; Get string pointer of product
0958   064A ED 53 19 0A 	ld		(flashProdPoint), de		; save it
0959   064E 23          	inc		hl
0960   064F 23          	inc		hl
0961   0650 7E          	ld		a, (hl)						; Get algorythm
0962   0651 32 16 0A    	ld		(flashAlg), a
0963   0654 23          	inc		hl
0964   0655 E5          	push	hl
0965   0656 ED 5B 17 0A 	ld		de, (flashManPoint)
0966   065A CD 69 05    	call	print
0967   065D ED 5B 19 0A 	ld		de, (flashProdPoint)
0968   0661 CD 69 05    	call	print
0969   0664 11 E6 06    	ld		de, strCrLf
0970   0667 CD 69 05    	call	print
0971   066A E1          	pop		hl
0972   066B 18 C0       	jr		.loop
0973   066D C9          	ret
0974   066E             
0975   066E             ; ----------------------
0976   066E             ; FlashIdent
0977   066E             ; Identifies Flash
0978   066E             ; ----------------------
0979   066E             flashIdent: 
0980   066E E5          	push	hl
0981   066F C5          	push	bc
0982   0670 D5          	push	de
0983   0671 21 47 09    	ld		hl, tblFlash				; HL points to table start
0984   0674 3A 14 0A    	ld		a, (flashIdMan)
0985   0677 47          	ld		b, a						; Manufacturer ID in B
0986   0678 16 00       	ld		d, 0
0987   067A             .loop: 
0988   067A 7E          	ld		a, (hl)
0989   067B FE 00       	cp		0							; no more entries?
0990   067D 28 2D       	jr z,	.naoId						; nop, unsucessfull!
0991   067F B8          	cp		b							; compares manufacturer ID
0992   0680 28 05       	jr z,	.idp						; Ok, detects product ID
0993   0682 1E 07       	ld		e, 7
0994   0684 19          	add		hl, de						; no matches, next entry
0995   0685 18 F3       	jr		.loop
0996   0687             .idp: 
0997   0687 23          	inc		hl							; compares product ID
0998   0688 3A 15 0A    	ld		a, (flashIdProd)
0999   068B BE          	cp		(hl)						; equal?
1000   068C 28 05       	jr z,	.ok							; Yes, sucessful
1001   068E 1E 06       	ld		e, 6
1002   0690 19          	add		hl, de						; no matches, next entry
1003   0691 18 E7       	jr		.loop
1004   0693             .ok: 
1005   0693 23          	inc		hl
1006   0694 5E 23 56 2B 	ld		de, (hl)
1007   0698 ED 53 17 0A 	ld		(flashManPoint), de
1008   069C 23          	inc		hl
1009   069D 23          	inc		hl
1010   069E 5E 23 56 2B 	ld		de, (hl)
1011   06A2 ED 53 19 0A 	ld		(flashProdPoint), de
1012   06A6 23          	inc		hl
1013   06A7 23          	inc		hl
1014   06A8 7E          	ld		a, (hl)
1015   06A9 32 16 0A    	ld		(flashAlg), a
1016   06AC             .naoId: 
1017   06AC D1          	pop		de
1018   06AD C1          	pop		bc
1019   06AE E1          	pop		hl
1020   06AF C9          	ret
1021   06B0             
1022   06B0             ; *** TEXTS ***
1023   06B0             
1024   06B0             strTitulo: 
1025   06B0             	.db		"SD Mapper flash programmer utility"
1025   06B0 5344204D617070657220666C6173682070726F6772616D6D6572207574696C69
1025   06D0 7479
1026   06D2 0D 0A       	.db		13, 10
1027   06D4             	.db		"(c) 2014 by FBLabs"
1027   06D4 28632920323031342062792046424C616273
1028   06E6             	; fall throw
1029   06E6             
1030   06E6             strCrLf: 
1031   06E6 0D 0A 24    	.db		13, 10, '$'
1032   06E9             
1033   06E9             strHelp: 
1034   06E9 0D 0A       	.db		13, 10
1035   06EB             	.db		"Usage:", 13, 10
1035   06EB 55736167653A0D0A
1036   06F3             	.db		"     sdmupd /opts <filename.ext>", 13, 10
1036   06F3 202020202073646D757064202F6F707473203C66696C656E616D652E6578743E
1036   0713 0D0A
1037   0715             	.db		"Example: sdmupd DRIVER.ROM", 13, 10
1037   0715 4578616D706C653A2073646D757064204452495645522E524F4D0D0A
1038   0731             	.db		"         sdmupd /e", 13, 10
1038   0731 20202020202020202073646D757064202F650D0A
1039   0745 0D 0A       	.db		13, 10
1040   0747             	.db		"Options:", 13, 10
1040   0747 4F7074696F6E733A0D0A
1041   0751             	.db		"     /h : Show this help.", 13, 10
1041   0751 20202020202F68203A2053686F7720746869732068656C702E0D0A
1042   076C             	.db		"     /l : Show list of supported chips.", 13, 10
1042   076C 20202020202F6C203A2053686F77206C697374206F6620737570706F72746564
1042   078C 2063686970732E0D0A
1043   0795             	.db		"     /e : Only erase flash and exit.", 13, 10
1043   0795 20202020202F65203A204F6E6C7920657261736520666C61736820616E642065
1043   07B5 7869742E0D0A
1044   07BB 24          	.db		'$'
1045   07BC             
1046   07BC             strProcuraFlash: 
1047   07BC             	.db		"Searching SD Mapper in system ...", 13, 10
1047   07BC 536561726368696E67205344204D617070657220696E2073797374656D202E2E
1047   07DC 2E0D0A
1048   07DF 24          	.db		'$'
1049   07E0             
1050   07E0             strNaoAchado: 
1051   07E0             	.db		"Oops! SD Mapper not Found!!", 13, 10
1051   07E0 4F6F707321205344204D6170706572206E6F7420466F756E6421210D0A
1052   07FD 24          	.db		'$'
1053   07FE             
1054   07FE             strAchado: 
1055   07FE             	.db		"Found in slot "
1055   07FE 466F756E6420696E20736C6F7420
1056   080C             .slot
1057   080C              
1058   080C 30          	.db		'0'
1059   080D             	.db		" subslot "
1059   080D 20737562736C6F7420
1060   0816             .subslot: 
1061   0816 30 3A 0D 0A 	.db		'0:', 13, 10
1062   081A 24          	.db		'$'
1063   081B             
1064   081B             strTraco: 
1065   081B 20 2D 20 24 	.db		" - $"
1066   081F             
1067   081F             strOk: 
1068   081F             	.db		" OK!", 13, 10
1068   081F 204F4B210D0A
1069   0825 24          	.db		'$'
1070   0826             
1071   0826             strErro: 
1072   0826 0D 0A       	.db		13, 10
1073   0828             	.db		"ERROR (BDOS)!!!!", 13, 10
1073   0828 4552524F52202842444F5329212121210D0A
1074   083A 24          	.db		'$'
1075   083B             
1076   083B             strErroAbrirArq: 
1077   083B 0D 0A       	.db		13, 10
1078   083D             	.db		"ERROR: Problems opening file ...", 13, 10
1078   083D 4552524F523A2050726F626C656D73206F70656E696E672066696C65202E2E2E
1078   085D 0D0A
1079   085F 24          	.db		'$'
1080   0860             
1081   0860             strTamanhoErrado: 
1082   0860 0D 0A       	.db		13, 10
1083   0862             	.db		"ERROR: File size must be 128KB"
1083   0862 4552524F523A2046696C652073697A65206D757374206265203132384B42
1084   0880 0D 0A 24    	.db		13, 10, '$'
1085   0883             
1086   0883             strOpenFile: 
1087   0883 0D 0A       	.db		13, 10
1088   0885             	.db		"Open file : "
1088   0885 4F70656E2066696C65203A20
1089   0891             .filename: 
1090   0891             	.db		"                "
1090   0891 20202020202020202020202020202020
1091   08A1 0D 0A 24    	.db		13, 10, '$'
1092   08A4             
1093   08A4             strEraseFlash: 
1094   08A4 0D 0A       	.db		13, 10
1095   08A6             	.db		"Erasing Flash "
1095   08A6 45726173696E6720466C61736820
1096   08B4 24          	.db		'$'
1097   08B5             
1098   08B5             strDot: 
1099   08B5 2A 24       	.db		'*$'
1100   08B7             
1101   08B7             strWriting: 
1102   08B7 0D 00 0A 00 	.dw 	13, 10
1103   08BB             	.db		"Writing: "
1103   08BB 57726974696E673A20
1104   08C4 24          	.db 	'$'
1105   08C5             
1106   08C5             strErroAoGravarFlash: 
1107   08C5 0D 0A       	.db		13, 10
1108   08C7             	.db		"ERROR: Writing Flash ...", 13, 10
1108   08C7 4552524F523A2057726974696E6720466C617368202E2E2E0D0A
1109   08E1 24          	.db		'$'
1110   08E2             
1111   08E2             strUpdateCompleto: 
1112   08E2 0D 0A       	.db		13, 10
1113   08E4             	.db		"Flash programmed succesfully.", 13, 10
1113   08E4 466C6173682070726F6772616D6D65642073756363657366756C6C792E0D0A
1114   0903 24          	.db		'$'
1115   0904             
1116   0904             strListaCab: 
1117   0904 0D 0A       	.db		13, 10
1118   0906             	.db		"List of supported flash chips:", 13, 10
1118   0906 4C697374206F6620737570706F7274656420666C6173682063686970733A0D0A
1119   0926             	.db		"------------------------------", 13, 10
1119   0926 2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D0D0A
1120   0946 24          	.db		'$'
1121   0947             
1122   0947             ; *** TABLES ***
1123   0947             ; AT49F002    = $1F $07		alg byte
1124   0947             ; AT49F002T   = $1F $08		alg byte
1125   0947             ; AT49(H)F010 = $1F $17		alg byte
1126   0947             ; AT29C010A   = $1F $D5		alg 128-page
1127   0947             ; AM29F010    = $01 $20		alg byte
1128   0947             ; SST29EE010  = $BF $07		alg 128-page
1129   0947             ; SST39SF020  = $BF $B6		alg byte
1130   0947             ; W49F002U/N  = $DA $0B		alg byte
1131   0947             ; W49F002B    = $DA $25		alg byte
1132   0947             ; W39F010     = $DA $A1		alg byte
1133   0947             ; 
1134   0947             
1135   0947             tblFlash: 
1136   0947 1F 07       	.db		$1F, $07
1137   0949 8E 09       		.dw strAtmel
1138   094B A8 09       		.dw strAt49f002
1139   094D 01          		.db ALG_BYTE
1140   094E 1F 08       	.db		$1F, $08
1141   0950 8E 09       		.dw strAtmel
1142   0952 B1 09       		.dw	strAt49F002t
1143   0954 01          		.db ALG_BYTE
1144   0955 1F 17       	.db		$1F, $17
1145   0957 8E 09       		.dw strAtmel
1146   0959 BB 09       		.dw	strAt49f010
1147   095B 01          		.db ALG_BYTE
1148   095C 1F D5       	.db		$1F, $D5
1149   095E 8E 09       		.dw strAtmel
1150   0960 C4 09       		.dw strAt29c010a
1151   0962 02          		.db ALG_PAGE
1152   0963 01 20       	.db		$01, $20
1153   0965 95 09       		.dw strAMD
1154   0967 CE 09       		.dw	strAm29F010
1155   0969 01          		.db	ALG_BYTE
1156   096A BF 07       	.db		$BF, $07
1157   096C 9A 09       		.dw	strSST
1158   096E D7 09       		.dw	strSst29ee010
1159   0970 02          		.db	ALG_PAGE
1160   0971 BF B6       	.db		$BF, $B6
1161   0973 9A 09       		.dw	strSST
1162   0975 E2 09       		.dw	strSst39sf020
1163   0977 01          		.db	ALG_BYTE
1164   0978 DA 0B       	.db		$DA, $0B
1165   097A 9F 09       		.dw	strWinb
1166   097C ED 09       		.dw	strW49f002un
1167   097E 01          		.db	ALG_BYTE
1168   097F DA 25       	.db		$DA, $25
1169   0981 9F 09       		.dw	strWinb
1170   0983 F8 09       		.dw	strW49f002b
1171   0985 01          		.db	ALG_BYTE
1172   0986 DA A1       	.db		$DA, $A1
1173   0988 9F 09       		.dw	strWinb
1174   098A 01 0A       		.dw	strW39f010
1175   098C 01          		.db	ALG_BYTE
1176   098D 00          	.db		0
1177   098E             
1178   098E             strAtmel: 
1179   098E             	.db		"Atmel $"
1179   098E 41746D656C2024
1180   0995             strAMD: 
1181   0995 414D442024  	.db		"AMD $"
1182   099A             strSST: 
1183   099A 5353542024  	.db		"SST $"
1184   099F             strWinb: 
1185   099F             	.db		"Winbond $"
1185   099F 57696E626F6E642024
1186   09A8             strAt49f002: 
1187   09A8             	.db		"AT49F002$"
1187   09A8 415434394630303224
1188   09B1             strAt49F002t: 
1189   09B1             	.db		"AT49F002T$"
1189   09B1 41543439463030325424
1190   09BB             strAt49f010: 
1191   09BB             	.db		"AT49F010$"
1191   09BB 415434394630313024
1192   09C4             strAt29c010a: 
1193   09C4             	.db		"AT29C010A$"
1193   09C4 41543239433031304124
1194   09CE             strAm29F010: 
1195   09CE             	.db		"AM29F010$"
1195   09CE 414D32394630313024
1196   09D7             strSst29ee010: 
1197   09D7             	.db		"SST29EE010$"
1197   09D7 5353543239454530313024
1198   09E2             strSst39sf020: 
1199   09E2             	.db		"SST39SF020$"
1199   09E2 5353543339534630323024
1200   09ED             strW49f002un: 
1201   09ED             	.db		"W49F002U/N$"
1201   09ED 57343946303032552F4E24
1202   09F8             strW49f002b: 
1203   09F8             	.db		"W49F002B$"
1203   09F8 573439463030324224
1204   0A01             strW39f010: 
1205   0A01             	.db		"W39F010$"
1205   0A01 5733394630313024
1206   0A09             
1207   0A09             ; *** VARIABLES ***
1208   0A09             
1209   0A09 00 00       savesp: 			.dw	0					; stack pointer
1210   0A0B 00          savecpu: 		.db	0					; cpu mode in Turbo R
1211   0A0C 00          savecursor: 		.db	0					; cursor
1212   0A0D 00          dos: 			.db	0					; dos version
1213   0A0E 00          system: 			.db	0					; msx version
1214   0A0F 00          options: 		.db	0					; options variable 1
1215   0A10 00          pages: 			.db	0					; 16 Kb Pages
1216   0A11 00          actualpage: 		.db	0					; Temporal page for load
1217   0A12 FF          thisslt: 		.db	0FFh				; sigslot flag
1218   0A13 00          flashslt: 		.db	0					; slot for flash
1219   0A14 00          flashIdMan: 		.db 0					; Flash Manufacturer ID
1220   0A15 00          flashIdProd: 	.db 0					; Flash Product ID
1221   0A16 00          flashAlg		.db 0					; Flash algorithm
1222   0A17 00 00       flashManPoint: 	.dw 0					; Flash manufacturer string pointer
1223   0A19 00 00       flashProdPoint: 	.dw	0					; Flash product string pointer
1224   0A1B             ;flashHalf:		.db	0					; What flash half is writing
1225   0A1B 00          togglebit: 		.db 0					; tmp variable for Flash Toggle Bit test
1226   0A1C 00          sizefiletmp: 	.ds	4					; tmp variable for READMAX Code
1227   0A20 00          fileHandle: 		.db	0					; DOS 2 File Handle
1228   0A21 00          fileNameDOS2: 	.ds	64					; Tmp for fileName
1229   0A61             fileNameDOS1: 	.db "        "			; DOS1 fileName for DOS1 Code
1229   0A61 2020202020202020
1230   0A69 20 20 20    filenDOS1Ext: 	.db	"   "
1231   0A6C 00          				.ds	4
1232   0A70             
1233   0A70             ; *** FCB DOS 1 ***
1234   0A70             FCB: 
1235   0A70 00          unidad: 		.db	0
1236   0A71 00          fileName: 	.ds	8
1237   0A79 00          extname: 	.ds	3
1238   0A7C 00 00       			.dw	0
1239   0A7E 00 00       registro: 	.dw	0
1240   0A80 00          sizefile: 	.ds	4
1241   0A84 00          			.ds	13
1242   0A91             sizeread: 
1243   0A91 00          			.ds	4
1244   0A95 00          			.db	0
1245   0A96             
